<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Centrimo</title>
    <script type="text/javascript">
      //@JSON_VAR data
      var data = {
        "version": "4.9.0",
        "revision": "dda626be5dfa",
        "release": "Wed Sep 19 09:32:35 EST 2012",
        "program": "CentriMo",
        "cmd": [
          "centrimo", "-local", "-ethresh", "1", "mm9_tss_500bp_sampled.fa",
          "some_vertebrates.meme"
        ],
        "options": {
          "motif-pseudo": 0.1,
          "score": 5,
          "optimize_score": false,
          "ethresh": 1,
          "maxbin": 0,
          "local": true,
          "norc": false,
          "flip": false,
          "noseq": false,
          "neg_sequences": false,
          "disc": false,
          "mcc": false
        },
        "seqlen": 500,
        "tested": 5,
        "sequence_db": {
          "source": "mm9_tss_500bp_sampled.fa",
          "count": 1000,
          "skipped": 0
        },
        "motif_dbs": [
          {
            "source": "some_vertebrates.meme",
            "count": 5
          }
        ],
        "sequences": [
          "1:164816396-164816896(-)_Fmo2",
          "8:19784482-19784982(+)_5330429B09Rik",
          "15:57743503-57744003(+)_Wdr67", "6:90251013-90251513(+)_BC048671",
          "X:51925137-51925637(+)_Gm16405", "1:12708375-12708875(+)_Sulf1",
          "4:14722949-14723449(-)_Lrrc69", "19:39815341-39815841(-)_Cyp2c68",
          "13:21271577-21272077(+)_Trim27", "7:8639617-8640117(+)_Vmn2r35",
          "6:127782732-127783232(+)_DQ719437",
          "X:83267195-83267695(-)_DQ560276",
          "2:167378563-167379063(+)_AK077405", "2:25763314-25763814(+)_Kcnt1",
          "18:35821590-35822090(-)_Spata24", "3:78949547-78950047(-)_Rapgef2",
          "X:139288532-139289032(-)_Ammecr1",
          "4:114659583-114660083(-)_Cmpk1", "14:54357800-54358300(+)_U46581",
          "3:9704752-9705252(-)_Pag1", "10:82337099-82337599(+)_Txnrd1",
          "4:98590250-98590750(+)_Usp1", "1:37552690-37553190(-)_Mgat4a",
          "X:83600083-83600583(-)_Gm41", "17:56651656-56652156(-)_Znrf4",
          "6:113342240-113342740(+)_Ttll3", "16:91782155-91782655(+)_Itsn1",
          "10:9394756-9395256(-)_Samd5", "7:51606676-51607176(+)_Shank1",
          "17:15636601-15637101(+)_Tbp", "11:101121630-101122130(+)_Wnk4",
          "4:131704194-131704694(-)_DQ687290",
          "18:67203355-67203855(-)_DQ700748", "1:59048017-59048517(+)_PAPK-A",
          "2:127595878-127596378(-)_Nphp1", "16:56204175-56204675(+)_Impg2",
          "2:147009568-147010068(+)_Nkx2-2as",
          "13:21703586-21704086(-)_Olfr1362",
          "5:138298024-138298524(+)_AK036462",
          "11:17059050-17059550(+)_Ppp3r1",
          "7:115303135-115303635(-)_Olfr485", "9:21875539-21876039(-)_Zfp653",
          "6:38825152-38825652(+)_Tbxas1", "7:134614877-134615377(+)_Prr14",
          "11:58269232-58269732(-)_Olfr30",
          "11:110858584-110859084(+)_Kcnj16",
          "13:84204127-84204627(-)_AK082072",
          "14:61656574-61657074(-)_Tnfrsf19",
          "6:48576512-48577012(+)_AI854703",
          "19:13869849-13870349(-)_Olfr1497", "11:82642295-82642795(-)_Rffl",
          "3:65469899-65470399(+)_Lekr1", "16:30599558-30600058(+)_Fam43a",
          "11:102465596-102466096(+)_Fzd2", "7:25266791-25267291(+)_Cadm4",
          "X:52016150-52016650(+)_Gm16405", "8:87502367-87502867(-)_Junb",
          "5:99283207-99283707(+)_Bmp3", "17:78973019-78973519(+)_Vit",
          "5:39698117-39698617(+)_AK076853", "9:106446756-106447256(-)_Iqcf3",
          "11:22882034-22882534(-)_Commd1", "X:71031986-71032486(-)_Idh3g",
          "9:42265418-42265918(-)_Tbcel", "4:66488594-66489094(+)_Tlr4",
          "2:87707899-87708399(+)_Olfr1152",
          "5:114250111-114250611(-)_Tmem119",
          "11:115476595-115477095(-)_Mif4gd",
          "13:44113641-44114141(-)_AK146979",
          "11:70846869-70847369(-)_6330403K07Rik",
          "10:62126287-62126787(+)_DQ714420",
          "7:23929249-23929749(-)_Gm10662", "9:45210970-45211470(+)_Fxyd2",
          "X:6645088-6645588(+)_Akap4", "11:54950295-54950795(+)_AK040665",
          "17:72022350-72022850(+)_Fam179a", "4:45120735-45121235(-)_Tomm5",
          "1:7149915-7150415(+)_Pcmtd1", "2:76820354-76820854(-)_Ttn",
          "X:71175939-71176439(-)_Renbp", "5:87765970-87766470(-)_Ugt2a3",
          "18:37813576-37814076(-)_AK150172",
          "4:133624116-133624616(+)_Aim1l", "14:51627175-51627675(+)_Rnase10",
          "6:108772520-108773020(-)_AK212603", "X:144636839-144637339(+)_Ott",
          "18:12287108-12287608(+)_Riok3", "11:5878265-5878765(-)_Camk2b",
          "17:24091990-24092490(-)_Sbpl", "7:16704974-16705474(+)_Kptn",
          "4:151665521-151666021(-)_Hes3", "8:124967072-124967572(-)_Mvd",
          "17:31301748-31302248(-)_Tff1", "6:83456713-83457213(-)_Dguok",
          "15:8273305-8273805(-)_Nipbl", "6:38612818-38613318(+)_Clec2l",
          "17:59135423-59135923(+)_AK015703",
          "10:10325492-10325992(+)_Gm5177",
          "19:30078029-30078529(+)_Trpd52l3",
          "7:48153444-48153944(-)_AK081136", "4:47486989-47487489(-)_Alg2",
          "9:110148548-110149048(+)_Cspg5", "18:64675961-64676461(-)_Nars",
          "11:33478707-33479207(-)_Gabrp", "X:68303180-68303680(+)_Mamld1",
          "19:12183784-12184284(-)_Olfr1428",
          "6:129543257-129543757(+)_Klrd1",
          "19:56896421-56896921(-)_A630007B06Rik",
          "11:32126254-32126754(+)_Mpg", "14:65792655-65793155(+)_AK076947",
          "11:54507274-54507774(+)_Rapgef6",
          "2:73398880-73399380(+)_AK029663", "3:151929034-151929534(-)_Nexn",
          "4:98787356-98787856(-)_Dock7", "2:132641540-132642040(-)_Trmt6",
          "19:59112630-59113130(-)_4930506M07Rik",
          "15:101197894-101198394(-)_Krt80",
          "10:114799037-114799537(-)_Tmem19", "2:30450313-30450813(+)_Cstad",
          "15:81605958-81606458(+)_Zc3h7b",
          "5:125483594-125484094(+)_Fam101a",
          "11:115999819-116000319(-)_Mrpl38",
          "6:128374678-128375178(-)_Itfg2", "19:56464275-56464775(-)_Nrap",
          "3:32430225-32430725(+)_Mfn1", "5:32438594-32439094(+)_Fosl2",
          "17:25853866-25854366(+)_Gng13", "12:28027333-28027833(-)_Sox11",
          "16:76373044-76373544(-)_Nrip1", "7:127288554-127289054(-)_Zp2",
          "5:76669721-76670221(-)_Clock", "7:108469387-108469887(+)_Stard10",
          "X:104283580-104284080(+)_P2ry10", "9:106402047-106402547(+)_Iqcf1",
          "19:12315899-12316399(-)_Olfr262",
          "11:109224718-109225218(-)_Gm11696",
          "13:50562425-50562925(+)_Gm806", "1:40571956-40572456(+)_Il18rap",
          "4:152071398-152071898(+)_Gm833", "9:15297625-15298125(+)_Fn5",
          "8:106833731-106834231(-)_Cklfsf2a",
          "2:113548577-113549077(+)_Fmn1", "9:22462473-22462973(+)_Bbs9",
          "16:8671996-8672496(-)_Carhsp1", "7:80265093-80265593(+)_DQ720136",
          "11:101489012-101489512(+)_Rdm1", "4:126698294-126698794(+)_Sfpq",
          "7:109264977-109265477(-)_Chrna10", "7:149657497-149657997(+)_Lsp1",
          "5:142945993-142946493(+)_C330006K01Rik",
          "12:66066273-66066773(-)_Klhl28", "5:123632445-123632945(-)_Hpd",
          "11:78639846-78640346(+)_1810012P15Rik",
          "10:84218542-84219042(+)_Rfx4", "6:49213801-49214301(-)_Tra2a",
          "2:74535569-74536069(+)_Hoxd9", "4:129419276-129419776(-)_Khdrbs1",
          "6:132687754-132688254(-)_Tas2r115",
          "17:75117723-75118223(+)_Ttc27", "9:108354820-108355320(-)_Klhdc8b",
          "5:127650684-127651184(+)_AK016281",
          "11:24630472-24630972(-)_Gm10466", "2:153743715-153744215(+)_Rya3",
          "3:109946140-109946640(-)_Ntng1", "10:79516531-79517031(+)_Gpx4",
          "9:72654830-72655330(+)_Prtg", "10:62486106-62486606(-)_AK156477",
          "5:130695363-130695863(+)_0610007L01Rik",
          "7:51501841-51502341(+)_2410002F23Rik",
          "14:43809686-43810186(+)_AK047145", "6:132545713-132546213(+)_Prp2",
          "14:52730327-52730827(+)_Rpgrip1", "8:28087557-28088057(+)_Zfp703",
          "12:59369995-59370495(-)_Clec14a", "5:114222570-114223070(+)_Iscu",
          "13:46764640-46765140(+)_C78339", "7:18830445-18830945(+)_Mill1",
          "13:5857088-5857588(-)_AK006031", "7:4073500-4074000(+)_Ttyh1",
          "2:92418838-92419338(+)_DQ556784", "X:148237950-148238450(+)_Huwe1",
          "19:38893477-38893977(-)_Noc3l", "2:29820829-29821329(+)_Spna2",
          "5:104599480-104599980(+)_Dspp", "19:29399558-29400058(-)_Insl6",
          "15:93349617-93350117(-)_Prickle1",
          "7:80937374-80937874(-)_DQ546551",
          "14:24902970-24903470(+)_DQ687046",
          "6:127756356-127756856(+)_DQ696633",
          "9:88851507-88852007(+)_Bcl2a1a", "9:57684263-57684763(-)_Arid3b",
          "4:129138672-129139172(+)_Bsdc1", "X:39264828-39265328(-)_Thoc2",
          "8:59029680-59030180(+)_Fbxo8", "17:27457540-27458040(-)_DQ701434",
          "4:155078673-155079173(+)_Ssu72", "13:96902282-96902782(-)_Sv2c",
          "7:4189105-4189605(+)_Lilra5", "5:38550456-38550956(-)_Nsg1",
          "6:91025719-91026219(-)_Nup210",
          "13:105653723-105654223(-)_Fam159b", "11:95528020-95528520(+)_Phb",
          "10:39679709-39680209(-)_G630090E17Rik",
          "12:110973578-110974078(+)_Mir453", "3:53326692-53327192(-)_Frem2",
          "8:4217062-4217562(-)_BC068157", "1:159465732-159466232(+)_Sec16b",
          "6:40949228-40949728(-)_Gm2663",
          "2:164653784-164654284(-)_1700020C07Rik",
          "12:117285684-117286184(+)_mKIAA4205",
          "17:88374139-88374639(+)_Msh6", "X:34784736-34785236(+)_Rhox2a",
          "17:65791407-65791907(-)_Tmem232",
          "8:108008077-108008577(-)_Zdhhc1",
          "14:51329756-51330256(+)_Olfr748", "X:34826361-34826861(+)_Rhox2b",
          "X:12618890-12619390(+)_AK017500", "17:45645563-45646063(+)_Aars2",
          "7:133768734-133769234(-)_Nupr1", "14:44579684-44580184(-)_Ang6",
          "11:35595647-35596147(+)_Mir103-1",
          "7:4072080-4072580(-)_9430041J12Rik",
          "18:37866632-37867132(+)_Pcdhga6", "16:94747986-94748486(-)_Dscr3",
          "5:130478448-130478948(-)_Gusb", "11:69694237-69694737(-)_Kctd11",
          "1:95341979-95342479(-)_Hdlbp", "9:54434067-54434567(+)_Idh3a",
          "2:5783719-5784219(-)_Gm13199", "X:35184612-35185112(+)_Rhox7",
          "2:89592733-89593233(-)_Olfr1253",
          "16:19407860-19408360(-)_Olfr165",
          "2:109753226-109753726(-)_Gm13939",
          "15:94459365-94459865(+)_Tmem117",
          "7:148617305-148617805(-)_Slc25a22",
          "7:148196393-148196893(-)_Ifitm3", "X:160875688-160876188(+)_Asb11",
          "2:29769663-29770163(+)_Odf2",
          "10:79783043-79783543(-)_2310011J03Rik",
          "11:84533684-84534184(-)_AK018946", "7:31383638-31384138(-)_Zbtb32",
          "7:67019107-67019607(-)_Snord116", "5:120926305-120926805(+)_Sds",
          "1:73062223-73062723(-)_Tnp1", "14:56340763-56341263(-)_Rabggta",
          "1:93302356-93302856(-)_1700020N18Rik",
          "19:5503537-5504037(-)_1700020D05Rik",
          "3:123375145-123375645(-)_Ndst3", "14:79987247-79987747(+)_Sugt1",
          "5:137926830-137927330(-)_Epo", "6:127738391-127738891(-)_DQ697314",
          "7:30640327-30640827(-)_AK204918",
          "8:22813869-22814369(-)_AY761184",
          "9:105998772-105999272(-)_Col6a4", "9:53619091-53619591(+)_Slc35f2",
          "4:41708932-41709432(+)_Il11ra1", "18:77303696-77304196(+)_Pias2",
          "17:34766380-34766880(+)_Prrt1", "6:129528053-129528553(+)_Klre1",
          "9:108419996-108420496(+)_Qrich1", "14:56472701-56473201(+)_Nynrin",
          "19:22766858-22767358(+)_Trpm3", "16:56717217-56717717(-)_Tfg",
          "16:88826140-88826640(-)_Krtap14", "9:107465335-107465835(+)_Tusc2",
          "2:24894775-24895275(+)_Pnpla7", "18:24280070-24280570(-)_Ino80c",
          "10:78819085-78819585(+)_Vmn2r82",
          "11:115024404-115024904(+)_Slc9a3r1",
          "18:37601920-37602420(+)_Pcdhb13", "7:3568724-3569224(+)_Ndufa3",
          "8:109589294-109589794(-)_Tmed6", "X:72823293-72823793(-)_Rab39b",
          "3:88717622-88718122(-)_Msto1", "16:96366775-96367275(+)_Wrb",
          "1:66991380-66991880(-)_Myl1", "1:130067956-130068456(+)_AK037193",
          "11:6963241-6963741(+)_Adcy1", "X:73509394-73509894(+)_Gm4937",
          "6:113690425-113690925(-)_Sec13", "11:69761386-69761886(-)_Slc2a4",
          "12:89680448-89680948(-)_AK015566",
          "7:116663395-116663895(+)_Snora3",
          "2:111824003-111824503(-)_Olfr1309",
          "7:137405330-137405830(-)_Fgfr2", "12:86691620-86692120(-)_Tmed10",
          "3:95984899-95985399(+)_Sv2a", "5:121264175-121264675(+)_oasl1",
          "1:53753038-53753538(+)_Mir1937b-2",
          "7:64845653-64846153(+)_Gabrb3", "2:89089599-89090099(-)_Olfr1228",
          "11:99417917-99418417(-)_Krtap3-2", "5:30339450-30339950(+)_Il6",
          "17:29052019-29052519(-)_4930539E08Rik",
          "2:10407511-10408011(+)_Mir467a-1",
          "8:107471005-107471505(+)_Ces2f",
          "7:139788819-139789319(+)_Nkx-1.2",
          "14:70107050-70107550(-)_R3hcc1",
          "14:33114859-33115359(+)_AK148313",
          "12:89054774-89055274(+)_BB287469", "16:18348116-18348616(+)_Arvcf",
          "5:93217338-93217838(-)_Mir1961", "8:125586637-125587137(+)_Spg7",
          "2:175736823-175737323(+)_Gm14308",
          "7:109636571-109637071(-)_Olfr544", "4:151413185-151413685(+)_Nol9",
          "7:21918897-21919397(-)_Vmn1r122",
          "4:120441977-120442477(-)_Mir30c-1", "X:7150996-7151496(-)_Ppp1r3f",
          "4:21858222-21858722(+)_6230409E13Rik",
          "9:61794356-61794856(-)_Kif23", "1:66909591-66910091(-)_Acadl",
          "16:90349637-90350137(-)_AK013372",
          "9:39580133-39580633(-)_Olfr968", "11:94277163-94277663(-)_Cacna1g",
          "10:32803038-32803538(+)_Trdn", "5:128058869-128059369(+)_AK145395",
          "3:143798468-143798968(-)_AK029620", "5:92834718-92835218(+)_art3",
          "11:20991870-20992370(+)_Peli1", "9:35365805-35366305(-)_Ddx25",
          "6:129862992-129863492(-)_Klra5",
          "5:138533673-138534173(+)_Zkscan1", "10:52137102-52137602(+)_Nus1",
          "17:15085578-15086078(-)_LOC106740", "2:60221038-60221538(-)_Ly75",
          "4:123130022-123130522(-)_Macf1", "15:85709506-85710006(+)_Trmu",
          "12:99643382-99643882(-)_DQ550484",
          "11:59734750-59735250(+)_AK007947",
          "11:99496148-99496648(-)_Krtap4-2",
          "10:85223265-85223765(+)_DQ725097", "5:36546419-36546919(+)_Psapl1",
          "2:164604984-164605484(-)_Tnnc2", "14:21299105-21299605(-)_Anxa7",
          "3:9402827-9403327(+)_C030034L19Rik",
          "1:36595953-36596453(-)_Ankrd23", "15:34766885-34767385(+)_Kcns2",
          "6:18377981-18378481(-)_Cttnbp2", "11:70807268-70807768(-)_Dhx33",
          "9:83303320-83303820(+)_DQ714940", "7:138175339-138175839(+)_Dmbt1",
          "9:119886202-119886702(-)_Csrnp1",
          "8:128363500-128364000(-)_Pcnxl2",
          "6:81848765-81849265(-)_DQ693585",
          "13:33576408-33576908(+)_Serpinb9g",
          "18:32047100-32047600(+)_Wdr33", "2:174109570-174110070(+)_Gnas",
          "5:136363538-136364038(+)_Hspb1",
          "10:111434070-111434570(-)_Glipr1",
          "15:5013498-5013998(-)_BC157982", "1:94370085-94370585(-)_Ndufa10",
          "6:30518125-30518625(+)_Cpa4", "1:87500216-87500716(-)_Sp110",
          "14:25187589-25188089(-)_DQ555142", "7:87550067-87550567(-)_Furin",
          "12:103508350-103508850(+)_AK047676",
          "2:136941817-136942317(-)_Jag1", "18:64609419-64609919(-)_S60130",
          "11:116613230-116613730(+)_BC018473",
          "7:20300358-20300858(-)_Tom40", "14:78707600-78708100(-)_Tnfsf11",
          "12:76770274-76770774(-)_Wdr89", "18:74375615-74376115(+)_Cxxc1",
          "5:145793383-145793883(-)_Gm4871", "7:94395054-94395554(+)_Kox-1",
          "19:8479345-8479845(-)_C730048C13Rik",
          "16:31933686-31934186(+)_Pigz", "11:53293447-53293947(-)_Ankrd43",
          "15:99555798-99556298(+)_2310016M24Rik",
          "13:22712654-22713154(-)_Vmn1r206",
          "2:92413794-92414294(+)_DQ559130", "2:109534315-109534815(+)_Bdnf",
          "2:32818570-32819070(+)_Snora65", "7:31198556-31199056(+)_Tyrobp",
          "11:65981264-65981764(+)_AK165802",
          "2:138103978-138104478(+)_Btbd3", "11:72903846-72904346(+)_Itgae",
          "2:130264054-130264554(+)_mVps16", "3:92568737-92569237(-)_Lce1h",
          "7:35841335-35841835(-)_Cebpg", "2:165329227-165329727(+)_Slc2a10",
          "11:50744887-50745387(-)_Zfp354b",
          "2:121282250-121282750(-)_Serinc4", "15:10643603-10644103(-)_Rai14",
          "7:109416087-109416587(+)_Stim1", "15:76540656-76541156(-)_Recql4",
          "4:154460156-154460656(-)_Rer1", "7:6125333-6125833(+)_Zfp444",
          "1:92811426-92811926(+)_Mlph", "3:88638899-88639399(+)_Gon4l",
          "7:123138350-123138850(-)_Sox6", "2:26747881-26748381(-)_AK043984",
          "18:77743601-77744101(-)_Akd2", "3:58935000-58935500(-)_P2ry14",
          "4:126738126-126738626(-)_Zmym1", "18:47697138-47697638(+)_Gm5095",
          "10:88720285-88720785(-)_Ano4", "6:127783343-127783843(+)_DQ569891",
          "7:16465054-16465554(-)_Crx", "9:105372227-105372727(-)_Atp2c1",
          "17:37248675-37249175(-)_Olfr92", "13:47158076-47158576(+)_Kdm1b",
          "12:36883162-36883662(-)_Bzw2", "9:67581194-67581694(-)_DQ685325",
          "11:43230065-43230565(-)_BC079904", "15:74630148-74630648(-)_Ly6k",
          "6:11875630-11876130(+)_Phf14", "10:22022391-22022891(-)_AK080063",
          "16:88612274-88612774(-)_Krtap24-1",
          "1:94846917-94847417(-)_9430060I03Rik",
          "11:95610063-95610563(+)_Zfp652", "3:151498737-151499237(-)_Ptgfr",
          "1:177618234-177618734(-)_Chml", "2:38852745-38853245(+)_Wdr38",
          "9:21351087-21351587(+)_Carm1", "2:166821489-166821989(-)_AK041781",
          "X:18723264-18723764(-)_Mir221", "3:32409221-32409721(+)_Zfp639",
          "9:108363157-108363657(-)_Klhdc8b", "13:49343825-49344325(-)_Susd3",
          "19:4712157-4712657(+)_Spnb3", "7:26601299-26601799(-)_Cyp2s1",
          "11:22871778-22872278(+)_Zrsr1", "18:37915358-37915858(-)_AK043330",
          "7:143045114-143045614(+)_AK031861",
          "1:187191159-187191659(+)_Eprs",
          "7:111506910-111507410(-)_A530023O14Rik",
          "3:10439874-10440374(-)_Snx16",
          "6:30462035-30462535(+)_1700025E21Rik",
          "2:152479816-152480316(-)_AK006531", "7:149202160-149202660(-)_Mmh",
          "15:83610202-83610702(+)_Mpped1", "15:102864147-102864647(+)_Hoxc4",
          "7:148286195-148286695(-)_Sigirr", "4:106583824-106584324(+)_Ssbp3",
          "5:72950002-72950502(-)_AK051057", "8:112514085-112514585(+)_Tat",
          "5:111082151-111082651(-)_Noc4l", "19:37759919-37760419(+)_Cyp26c1",
          "7:107810658-107811158(-)_Plekhb1", "11:82721647-82722147(-)_Nle1",
          "10:118156234-118156734(-)_AK089123",
          "12:70297947-70298447(+)_9330151L19Rik",
          "7:80960564-80961064(-)_DQ698370", "19:41970393-41970893(-)_Rrp12",
          "X:10876132-10876632(+)_Gm14483",
          "6:124807455-124807955(-)_Leprel2",
          "13:34169627-34170127(-)_Tubb2a", "8:28405532-28406032(-)_DQ545254",
          "X:71136930-71137430(+)_Avpr2", "10:127984550-127985050(-)_Zc3h10",
          "3:146184137-146184637(-)_Rpf1", "3:96380656-96381156(+)_AK052161",
          "1:135188315-135188815(+)_AK020645", "11:40546689-40547189(-)_Hmmr",
          "12:87762343-87762843(+)_Esrrb", "8:40727782-40728282(-)_Msr1",
          "9:39758104-39758604(-)_Olfr975", "1:36614976-36615476(-)_Sema4c",
          "13:110114687-110115187(+)_Mir582", "9:53109524-53110024(+)_Exph5",
          "2:5872264-5872764(+)_Upf2", "19:39005229-39005729(+)_Hells",
          "13:35997966-35998466(-)_Rpp40", "7:132746692-132747192(+)_Il21r",
          "2:91096719-91097219(+)_Pacsin3", "1:97209954-97210454(+)_Fam174a",
          "4:106798967-106799467(+)_AK084081",
          "8:125091664-125092164(+)_Cdt1", "15:97661852-97662352(-)_Hdac7",
          "3:82161715-82162215(+)_Mtap9", "3:95685878-95686378(-)_Gm129",
          "6:127022669-127023169(+)_Fgf23", "13:53567899-53568399(-)_Msx2",
          "7:58713483-58713983(+)_DQ714940",
          "7:10462062-10462562(-)_AK083498",
          "2:25993573-25994073(-)_AK082757", "18:10798099-10798599(+)_Mib1",
          "3:148491282-148491782(-)_Lphn2", "17:37971605-37972105(+)_Olfr125",
          "10:62126942-62127442(+)_DQ554303", "6:99112773-99113273(-)_Foxp1",
          "2:150434009-150434509(-)_2310001A20Rik",
          "9:35007240-35007740(-)_Tirap", "19:4127326-4127826(+)_Tmem134",
          "8:11550521-11551021(-)_Cars2", "2:172687680-172688180(+)_BC116387",
          "9:64948502-64949002(+)_Igdcc4", "16:48283597-48284097(+)_Dppa4",
          "11:20546905-20547405(+)_Sertad2",
          "2:92241170-92241670(-)_Mapk8ip1", "5:122043583-122044083(-)_Aldh2",
          "16:21153767-21154267(-)_2310042E22Rik",
          "14:22808573-22809073(-)_Zfp503", "10:61246362-61246862(-)_H2afy2",
          "2:158328097-158328597(+)_Adig",
          "10:68004373-68004873(-)_1700040L02Rik",
          "15:78499869-78500369(-)_DQ549194", "16:23428955-23429455(+)_Rtp1",
          "17:27452336-27452836(-)_DQ553816", "16:89974694-89975194(-)_Tiam1",
          "5:121098580-121099080(+)_Rasal1", "10:79408773-79409273(+)_Arid3a",
          "5:8798273-8798773(-)_AK079527", "7:97574571-97575071(+)_Ccdc89",
          "1:176081361-176081861(+)_Olfr421", "4:155041028-155041528(-)_Mib2",
          "14:20463614-20464114(-)_DQ554183", "13:20564711-20565211(+)_Elmo1",
          "X:75109846-75110346(+)_Gm14744", "9:86465199-86465699(-)_Pgm3",
          "7:12516384-12516884(-)_Vmn1r76", "5:121311180-121311680(+)_Oas1h",
          "14:54800945-54801445(+)_TCR-alpha_chain",
          "8:8661550-8662050(+)_AK007249", "14:102237478-102237978(+)_Lmo7",
          "4:144276021-144276521(-)_Gm436", "13:27941020-27941520(+)_Prl2c1",
          "13:34129259-34129759(+)_Bphl", "1:32577594-32578094(-)_Gm9839",
          "18:11998697-11999197(-)_Mir1901", "2:103809463-103809963(+)_Lmo2",
          "12:86629290-86629790(+)_Fam164c", "8:72826101-72826601(-)_Ddx49",
          "12:12268694-12269194(+)_Fam49a", "8:49640336-49640836(-)_Odz3",
          "4:107013340-107013840(+)_Yipf1",
          "12:20821390-20821890(-)_1700030C10Rik",
          "2:31701275-31701775(-)_Fibcd1", "8:73278327-73278827(+)_Rab3a",
          "13:50639853-50640353(-)_Mir683-1",
          "2:10295418-10295918(-)_AK076687", "2:30141624-30142124(-)_Dolk",
          "5:72091004-72091504(+)_Gabrb1", "7:80980230-80980730(+)_DQ726065",
          "7:31947126-31947626(+)_AK133438", "2:7317377-7317877(-)_Celf2",
          "9:53697807-53698307(+)_Sln", "3:85377617-85378117(-)_AK158189",
          "11:115794722-115795222(+)_Sap30bp",
          "7:114179399-114179899(+)_Olfr713",
          "15:103164508-103165008(-)_Zfp385a",
          "13:22944114-22944614(-)_Vmn1r211",
          "8:122223658-122224158(+)_Atp2c2",
          "4:135528259-135528759(-)_Lypla2", "12:117690402-117690902(+)_Mtb",
          "8:113861553-113862053(-)_Mlkl", "9:39420903-39421403(+)_Olfr148",
          "13:89878814-89879314(+)_AK040967",
          "12:11210965-11211465(-)_AK020565", "4:42375226-42375726(-)_Ccl19",
          "2:26720249-26720749(-)_Abo",
          "8:125771532-125772032(-)_1300018I17Rik",
          "7:28553999-28554499(+)_Gm10046", "11:102680223-102680723(-)_Gjc1",
          "16:32147717-32148217(-)_Lrrc33", "12:85741558-85742058(-)_Entpd5",
          "18:23655732-23656232(+)_Dtna", "4:15076691-15077191(-)_Necab1",
          "19:44210116-44210616(-)_Cwf19l1",
          "4:56237143-56237643(-)_AK010245", "9:90009185-90009685(-)_Morf4l1",
          "17:33961193-33961693(-)_Rps28", "12:77938203-77938703(+)_Fntb",
          "1:75356668-75357168(+)_Des",
          "7:148550759-148551259(-)_B230206H07Rik",
          "18:69752829-69753329(+)_Tcf4", "4:155148420-155148920(-)_Vwa1",
          "5:45841218-45841718(-)_Qdpr", "9:37704740-37705240(+)_Olfr145",
          "8:86700201-86700701(-)_Nanos3", "11:114590211-114590711(+)_Dnaic2",
          "7:20381908-20382408(-)_Cblc", "1:176088602-176089102(+)_Olfr420",
          "9:72961025-72961525(+)_Rsl24d1", "6:146980808-146981308(+)_Rep15",
          "4:155560093-155560593(-)_Agrn", "5:66358112-66358612(+)_Chrna9",
          "2:176420778-176421278(-)_Gm14308", "7:3866853-3867353(-)_Pira1",
          "2:10405054-10405554(+)_Mir467a-3", "5:66934606-66935106(-)_Apbb2",
          "14:3347849-3348349(+)_Gm2897", "X:131499043-131499543(-)_Nxf2",
          "4:94242829-94243329(-)_Plaa", "1:65357580-65358080(+)_Pth2r",
          "3:121948259-121948759(+)_Gclm", "13:23961891-23962391(+)_Slc17a1",
          "13:12556959-12557459(-)_Lgals8", "9:44192269-44192769(+)_Hyou1",
          "8:3854036-3854536(-)_Cd209e", "15:8243008-8243508(-)_Nipbl",
          "7:12778063-12778563(+)_Vmn1r80", "15:31399182-31399682(-)_March6",
          "7:99383365-99383865(+)_Dlg2", "3:159158146-159158646(+)_Depdc1a",
          "3:88018156-88018656(+)_AK140632",
          "3:120965557-120966057(-)_Tmem56",
          "10:129062865-129063365(-)_Olfr798",
          "11:83880337-83880837(-)_Dusp14",
          "5:146105888-146106388(+)_Cyp3a57",
          "1:182834154-182834654(+)_Pycr2", "14:12385816-12386316(+)_Ptprg",
          "4:115236071-115236571(+)_Cyp4a31",
          "6:85939909-85940409(-)_DQ685631", "3:89126551-89127051(-)_Efna3",
          "11:4773755-4774255(+)_Nipsnap1", "15:98286492-98286992(+)_Olfr281",
          "2:174153164-174153664(+)_Gnas", "2:120197116-120197616(-)_Tmem87a",
          "15:98051237-98051737(-)_Olfr288",
          "7:80284276-80284776(+)_DQ542042",
          "2:86226323-86226823(-)_Olfr1058", "2:154203702-154204202(-)_Snta1",
          "14:76636476-76636976(-)_AK205379", "15:99500898-99501398(+)_Accn2",
          "7:58766148-58766648(+)_Ano5", "2:153700530-153701030(+)_Bpil1",
          "18:46458892-46459392(-)_Ccdc112", "3:108393945-108394445(+)_Wdr47",
          "1:194668246-194668746(+)_AK006895", "1:93903182-93903682(-)_Hdac4",
          "1:138027498-138027998(-)_BC115961",
          "13:67433246-67433746(-)_Zfp595", "11:115264815-115265315(+)_Ict1",
          "4:117354580-117355080(-)_Dmap1", "11:109472453-109472953(-)_Wipi1",
          "4:95807483-95807983(-)_Cyp2j12-ps",
          "11:87794088-87794588(-)_Gdi-1",
          "X:133461613-133462113(+)_1700014N06Rik",
          "10:61158011-61158511(+)_Tysnd1", "4:136604360-136604860(-)_Zbtb40",
          "16:74352872-74353372(-)_Robo2", "9:91272786-91273286(+)_Zic4",
          "15:12047355-12047855(+)_Zfr", "4:42211553-42212053(+)_DQ545836",
          "13:22647819-22648319(+)_Vmn1r204",
          "5:30080686-30081186(+)_AK153014", "8:86064741-86065241(+)_Olfr370",
          "11:115741300-115741800(+)_Myo15b",
          "9:58337164-58337664(+)_6030419C18Rik",
          "13:50125021-50125521(+)_DQ726010",
          "9:108469423-108469923(-)_Ndufaf3", "12:4038665-4039165(-)_Efr3b",
          "8:12395268-12395768(+)_Sox1", "2:30033699-30034199(-)_D2Wsu81e",
          "7:138686226-138686726(+)_Hmx3",
          "2:111378194-111378694(-)_Olfr1294",
          "12:105485855-105486355(+)_Serpina3h",
          "14:53535372-53535872(+)_TCRA", "12:88855015-88855515(+)_Gm8300",
          "17:7189003-7189503(+)_Rnaset2b",
          "11:118770636-118771136(-)_Rbfox3",
          "1:44158938-44159438(-)_1700029F09Rik",
          "X:12857897-12858397(+)_Ddx3x", "7:31206500-31207000(+)_Nfkbid",
          "2:117127507-117128007(-)_Rasgrp",
          "9:27160019-27160519(+)_AI414108",
          "14:52755956-52756456(+)_Rpgrip1", "1:137221139-137221639(+)_Lmod1",
          "4:133684418-133684918(-)_Sh3bgrl3",
          "10:99798059-99798559(+)_Gm4301", "1:164914372-164914872(-)_Fmo3",
          "2:109757553-109758053(+)_Lgr4", "11:54409397-54409897(+)_Rapgef6",
          "2:151821996-151822496(+)_2310046K01Rik",
          "2:62502133-62502633(+)_Gca", "14:46242615-46243115(-)_Ddhd1",
          "7:142601799-142602299(+)_Foxi2", "17:37498802-37499302(+)_Olfr104",
          "11:65548084-65548584(-)_Mir744",
          "11:32247560-32248060(+)_Sh3pxd2b",
          "2:135713176-135713676(+)_Plcb4",
          "16:52815607-52816107(-)_AK015072",
          "19:6127929-6128429(-)_AK045837", "15:68090168-68090668(-)_Zfat",
          "11:68803858-68804358(-)_Pfas", "5:31502945-31503445(-)_Zfp513",
          "18:81171114-81171614(-)_Sall3", "8:86222828-86223328(-)_Pkn1",
          "9:88222196-88222696(+)_Nt5e", "2:167284898-167285398(+)_NHE8",
          "2:73153238-73153738(+)_Scrn3", "X:71330725-71331225(-)_Mecp2",
          "10:117780040-117780540(+)_AB339931",
          "9:106060219-106060719(-)_Glyctk", "6:41797297-41797797(+)_Pip",
          "1:132782323-132782823(-)_Il24", "12:53896573-53897073(+)_Akap6",
          "1:21477164-21477664(-)_Kcnq5", "7:110819293-110819793(-)_Olfr624",
          "17:26232165-26232665(-)_Nme4", "2:44782506-44783006(-)_Gtdc1",
          "7:63023297-63023797(+)_Siglech",
          "12:99683644-99684144(+)_DQ544519",
          "7:109862675-109863175(-)_Olfr33", "6:48543631-48544131(+)_Repin1",
          "2:154477227-154477727(+)_Chmp4b", "7:152469582-152470082(-)_Tpcn2",
          "X:69177526-69178026(+)_Gm1141", "17:24733978-24734478(-)_Tsc2",
          "17:75834994-75835494(+)_Rasgrp3", "10:40602699-40603199(-)_Cdc40",
          "9:63450005-63450505(-)_Iqch", "11:103273728-103274228(-)_Plekhm1",
          "7:110905614-110906114(-)_Olfr630",
          "14:51272663-51273163(+)_Olfr746", "6:41722046-41722546(-)_Olfr459",
          "9:39358204-39358704(-)_Olfr958", "4:117600725-117601225(-)_Artn",
          "4:43519647-43520147(+)_Car9", "7:139611462-139611962(+)_AK086971",
          "17:89191066-89191566(-)_Lhcgr", "10:82912205-82912705(+)_AB339387",
          "19:47993539-47994039(-)_D19Ertd652e",
          "7:20147497-20147997(-)_Lrrc68", "8:126329645-126330145(+)_Rab4a",
          "9:78039522-78040022(+)_Gsta4", "3:123149580-123150080(+)_Prss12",
          "11:99299217-99299717(-)_Krt20", "15:5066362-5066862(+)_Rpl37",
          "1:169279871-169280371(+)_Aldh9a1",
          "10:80657185-80657685(+)_2310050B05Rik",
          "4:62895069-62895569(+)_mKIAA1870",
          "11:96608474-96608974(-)_AK008491", "6:71911267-71911767(+)_Polr1a",
          "1:141677566-141678066(-)_EG214403",
          "2:157562886-157563386(+)_Ctnnbl1",
          "2:165213509-165214009(-)_Zfp334",
          "5:125205199-125205699(-)_AK161424",
          "14:52078110-52078610(+)_Vmn2r121", "7:67594813-67595313(-)_Snrpn",
          "4:62626357-62626857(+)_Znf618", "5:38666960-38667460(+)_Otop1",
          "1:89700004-89700504(+)_Sag", "9:19300943-19301443(+)_Olfr851",
          "12:74387448-74387948(-)_Trmt5",
          "2:155833463-155833963(-)_6430550D23Rik",
          "2:146047482-146047982(+)_Insm1", "11:116077065-116077565(+)_Cdk3",
          "13:29045301-29045801(-)_Sox4", "17:23863052-23863552(+)_Pkmyt1",
          "12:114727525-114728025(+)_Adam6b", "13:93124708-93125208(-)_Msh3",
          "14:72955916-72956416(-)_mKIAA0970", "11:46250198-46250698(+)_Med7",
          "7:151739384-151739884(-)_Ppfia1",
          "2:109890386-109890886(-)_AK006310",
          "6:115788180-115788680(-)_BC060267",
          "3:141644965-141645465(-)_Bmpr1b", "2:14970689-14971189(-)_Nsun6",
          "7:110334866-110335366(+)_Olfr592", "2:4839791-4840291(+)_Phyh",
          "18:25327128-25327628(-)_5730494M16Rik",
          "10:78054459-78054959(-)_Syde1", "1:190085651-190086151(+)_Ush2a",
          "17:71660646-71661146(-)_Emilin2", "13:81723605-81724105(-)_Gpr98",
          "1:180866990-180867490(+)_BC023483",
          "16:23520413-23520913(-)_Masp1", "2:123915454-123915954(+)_Sema6d",
          "2:172847152-172847652(+)_Rbm38", "8:22223870-22224370(+)_Defa25",
          "3:99689089-99689589(+)_Spag17",
          "6:132711898-132712398(+)_Tas2r102",
          "2:77745974-77746474(-)_AK039942",
          "6:146596074-146596574(-)_Gm6654", "3:96473803-96474303(+)_Ankrd35",
          "X:51019505-51020005(-)_AK082553", "15:76456207-76456707(-)_Vps28",
          "7:27179012-27179512(-)_Nlrp9c", "15:82129163-82129663(+)_Wbp2nl",
          "18:46887746-46888246(-)_Cdo1", "7:149361660-149362160(-)_Krtap5-2",
          "11:22878746-22879246(-)_Commd1", "3:90472742-90473242(+)_S100a8",
          "7:88974067-88974567(-)_Btbd1", "4:132753066-132753566(+)_AK199358",
          "19:43598845-43599345(-)_Got1",
          "14:100612157-100612657(+)_AK015818",
          "5:77020489-77020989(+)_Cep135", "14:124591518-124592018(-)_Fgf14",
          "6:130697391-130697891(-)_AK136154",
          "X:88576843-88577343(+)_Mageb2", "15:65618352-65618852(+)_KIAA0143",
          "7:26274261-26274761(-)_Ceacam1", "19:7049287-7049787(+)_Ppp1r14b",
          "10:86668473-86668973(+)_1700113H08Rik",
          "7:85882648-85883148(-)_E430016F16Rik",
          "9:39234404-39234904(-)_Olfr952", "5:115635880-115636380(-)_Cabp1",
          "14:69912106-69912606(-)_D930020E02Rik",
          "8:108497998-108498498(+)_AK139607",
          "17:35202879-35203379(-)_AU023871", "7:5148099-5148599(-)_Vmn1r56",
          "3:135988760-135989260(-)_Bank1",
          "6:129300011-129300511(+)_Clec12a", "7:148358500-148359000(-)_Rnh1",
          "7:130140206-130140706(+)_Rbbp6", "14:55479077-55479577(-)_Homez",
          "5:77447638-77448138(-)_AK018948", "4:57314459-57314959(-)_Ptpn3",
          "4:138469612-138470112(-)_Otud3", "X:11657429-11657929(-)_Bcor",
          "X:7419473-7419973(+)_Otud5", "15:78490541-78491041(-)_DQ714866",
          "17:25923274-25923774(+)_Ccdc78", "8:80073045-80073545(+)_Prmt10",
          "11:11013768-11014268(+)_Vwc2", "14:27077703-27078203(+)_Gm10394",
          "1:52901639-52902139(+)_Hibch", "16:32099563-32100063(-)_Pigx",
          "Y:395061-395561(-)_Tspy-ps", "14:51043945-51044445(+)_Olfr739",
          "14:122505946-122506446(-)_A330035P11Rik",
          "14:57319855-57320355(-)_AK045225", "11:82988437-82988937(+)_Slfn4",
          "13:54652870-54653370(+)_AK216920",
          "19:12496550-12497050(+)_Olfr1441",
          "2:157917283-157917783(-)_AK008166",
          "7:127986146-127986646(+)_Eef2k",
          "7:106929748-106930248(-)_AK089468",
          "11:81673924-81674424(+)_AK017430", "5:96515702-96516202(-)_Cnot6l",
          "17:36909604-36910104(+)_H2-M10.5", "19:28400246-28400746(-)_Glis3",
          "X:109206878-109207378(+)_Tex16", "3:88490069-88490569(-)_AK078352",
          "13:22445964-22446464(+)_Vmn1r198",
          "12:102956462-102956962(-)_Tc2n", "11:72267793-72268293(-)_Spns2",
          "10:14264592-14265092(-)_Gpr126", "3:90051863-90052363(+)_Slc39a1",
          "14:49284534-49285034(-)_Otx2", "7:68880238-68880738(-)_Mir344e",
          "7:120285279-120285779(-)_AK016028",
          "17:49567438-49567938(+)_Mocs1", "9:106558190-106558690(-)_Grm2",
          "4:42599853-42600353(-)_DQ713008", "12:16933494-16933994(+)_Rock1",
          "8:77357596-77358096(-)_AK166041", "X:53862761-53863261(+)_Slc9a6",
          "6:87863719-87864219(+)_8430410A17Rik",
          "7:52238995-52239495(-)_Prmt1", "4:73065856-73066356(-)_Gm11487",
          "13:75977083-75977583(+)_Glrx", "8:125286411-125286911(-)_AK079929",
          "19:10651321-10651821(-)_Tmem138",
          "4:115190641-115191141(+)_Cyp4a10", "5:33084632-33085132(-)_Pisd",
          "7:105326453-105326953(-)_Capn5", "18:34701731-34702231(+)_Wnt8a",
          "7:125998877-125999377(-)_2310008H09Rik",
          "5:15186277-15186777(+)_Speer7-ps1", "14:56793183-56793683(-)_Gzmn",
          "4:12014898-12015398(-)_Tmem67", "19:53674635-53675135(+)_Smc3",
          "9:55359800-55360300(-)_Etfa", "5:123721353-123721853(+)_Wdr66",
          "2:162880120-162880620(+)_Mybl2",
          "12:112216981-112217481(-)_Ankrd9", "12:4274758-4275258(-)_Ncoa1",
          "11:115626505-115627005(+)_2310067B10Rik",
          "14:51715424-51715924(+)_Ang",
          "15:34287377-34287877(-)_9430069I07Rik",
          "3:92748157-92748657(+)_Lce3c",
          "9:107301960-107302460(+)_mKIAA0558",
          "6:52150872-52151372(+)_2700086A05Rik",
          "2:49474583-49475083(+)_Kif5c", "14:51152838-51153338(+)_Olfr743",
          "10:119800976-119801476(+)_BC098228",
          "11:6559989-6560489(-)_Gm11978", "9:120842267-120842767(+)_Ctnnb1",
          "X:73638438-73638938(+)_4930428D18Rik",
          "2:127657345-127657845(-)_Bub1", "3:20054745-20055245(-)_Gyg",
          "6:34395185-34395685(-)_AK133155",
          "1:138178826-138179326(-)_Camsap1l1",
          "16:19624944-19625444(-)_Olfr171",
          "9:109351404-109351904(-)_Fbxw16",
          "2:172265827-172266327(+)_2410001C21Rik",
          "14:75597625-75598125(+)_Lcp1", "7:104464254-104464754(-)_Usp35",
          "2:25278512-25279012(+)_Fut7", "14:16270447-16270947(+)_AK080648",
          "10:19927994-19928494(+)_Gm6251", "11:51103171-51103671(+)_Col23a1",
          "13:5860484-5860984(+)_Klf6", "7:51079663-51080163(+)_Klk6",
          "10:103615157-103615657(+)_Gm4303",
          "18:13038236-13038736(-)_Osbpl1a",
          "13:78341384-78341884(+)_AK044036",
          "17:20319811-20320311(-)_Fpr-rs6",
          "8:126383180-126383680(-)_1700054N08Rik",
          "10:36694099-36694599(+)_Hdac2", "2:75819774-75820274(-)_Ttc30a1",
          "2:32480706-32481206(+)_Ak1", "18:62900791-62901291(-)_Spink13",
          "6:6831818-6832318(-)_Dlx5", "14:24915851-24916351(+)_DQ692484",
          "15:83130194-83130694(+)_AK206687", "19:30249658-30250158(-)_Gldc",
          "13:21408876-21409376(+)_Gpx6", "15:76341998-76342498(-)_Dgat1",
          "2:153769408-153769908(+)_Gm1006",
          "6:67515443-67515943(-)_4930515G16Rik",
          "9:95650527-95651027(-)_Trpc1", "2:90585276-90585776(+)_Fnbp4",
          "8:34627545-34628045(+)_Tex15", "15:26825069-26825569(-)_Fbxl7",
          "7:151768091-151768591(-)_Fadd", "19:55291684-55292184(-)_Gucy2g",
          "4:25726900-25727400(-)_Fut9", "13:33057131-33057631(+)_Serpinb6b",
          "17:57226955-57227455(-)_Tubb4", "4:42787275-42787775(-)_Gm1987",
          "1:89872256-89872756(-)_Usp40", "15:36426296-36426796(-)_Ankrd46",
          "8:90806640-90807140(+)_Adcy7",
          "10:116675487-116675987(-)_9530003J23Rik",
          "6:116666526-116667026(-)_Tmem72",
          "3:132541310-132541810(-)_AK135894",
          "5:130731082-130731582(-)_Sbds", "15:36936907-36937407(-)_Zfp706",
          "7:52184610-52185110(-)_Ap2a1", "2:32286421-32286921(-)_Slc25a25",
          "6:145251421-145251921(+)_AK008222",
          "11:113544986-113545486(-)_D11Wsu99e",
          "17:22498117-22498617(-)_Zfp944",
          "2:120139651-120140151(-)_Pla2g4f",
          "3:145238921-145239421(+)_Znhit6",
          "5:35258313-35258813(+)_A930005I04Rik",
          "4:41756281-41756781(+)_DQ707320", "13:27604832-27605332(-)_Prl8a8",
          "8:34842560-34843060(+)_Gtf2e2", "13:22474156-22474656(+)_Vmn1r199",
          "4:114672472-114672972(+)_Stil", "5:121364576-121365076(+)_Oas1d",
          "11:3439045-3439545(-)_Smtn", "3:54858714-54859214(-)_Ccna1",
          "17:74616208-74616708(-)_Memo1", "12:106842050-106842550(+)_Bdkrb1",
          "5:136164833-136165333(+)_Por", "18:7868605-7869105(+)_Wac",
          "14:20465191-20465691(-)_DQ691236",
          "7:146574757-146575257(+)_Inpp5a",
          "4:93975341-93975841(-)_DQ704887", "7:34880199-34880699(+)_Gm12776",
          "10:111609345-111609845(+)_Caps2",
          "6:113060160-113060660(+)_mKIAA1757",
          "6:31380431-31380931(+)_Mkln1", "5:124875337-124875837(-)_Sbno1",
          "17:66569623-66570123(+)_DQ712916", "X:13788023-13788523(+)_Gm5382",
          "3:140571181-140571681(-)_AK076796",
          "13:67522104-67522604(-)_Zfp459", "15:44288848-44289348(+)_Pkhd1l1",
          "13:43655310-43655810(-)_Ccdc90a", "2:135813322-135813822(+)_Plcb4",
          "17:35031253-35031753(+)_Zbtb12",
          "19:36525397-36525897(-)_AK165489",
          "1:168577574-168578074(-)_Gm4847",
          "10:129311561-129312061(-)_Olfr814", "1:130224645-130225145(-)_Lct",
          "11:57917404-57917904(+)_Cnot8", "17:27464638-27465138(+)_DQ692167",
          "2:19916074-19916574(+)_AK216824", "19:48280264-48280764(+)_Sorcs3",
          "1:132525933-132526433(-)_Zp3r", "14:66696320-66696820(-)_Adam2",
          "13:23522636-23523136(-)_C230035I16Rik",
          "X:91881157-91881657(+)_Gspt2", "7:107412803-107413303(+)_Gpx2-ps1",
          "16:34784785-34785285(+)_Mylk", "17:34807229-34807729(+)_Tnxb",
          "19:6067600-6068100(-)_Tm7sf2", "14:45554889-45555389(+)_DQ690575",
          "6:28084119-28084619(-)_Grm8", "X:66014763-66015263(+)_Fmr1nb",
          "9:65113369-65113869(+)_Cilp", "19:26822642-26823142(+)_Smarca2",
          "1:66221652-66222152(+)_Mtap2", "9:109470526-109471026(-)_Fbxw15",
          "19:5050557-5051057(+)_Rin1", "10:75683657-75684157(-)_Prmt2",
          "7:111990768-111991268(-)_Dub1a",
          "7:109702549-109703049(+)_Olfr549", "10:4423890-4424390(+)_Rgs17",
          "11:99982559-99983059(-)_Krt13", "6:38501193-38501693(+)_Luc7l2",
          "X:7708595-7709095(-)_Wdr13", "5:100506730-100507230(+)_AK017893",
          "17:26335782-26336282(-)_Pdia2", "15:94234531-94235031(-)_Adamts20",
          "3:40886718-40887218(-)_Pgrmc2", "3:85357061-85357561(-)_AK086005",
          "19:53216995-53217495(+)_Add3", "8:74061086-74061586(-)_Bst2",
          "9:96789591-96790091(-)_Acpl2"
        ],
        "motifs": [
          {
            "db": 0,
            "id": "MA0108.1",
            "alt": "TBP",
            "len": 15,
            "motif_evalue": "0.0e-000",
            "motif_nsites": 388,
            "n_tested": 118340,
            "score_threshold": 5.12743,
            "url": "http:\/\/jaspar.genereg.net\/cgi-bin\/jaspar_db.pl?ID=MA0108.1&rm=present&collection=CORE",
            "pwm": [
              [0.156829, 0.372723, 0.390717, 0.0797314], 
              [0.0411783, 0.11829, 0.0463317, 0.794199], 
              [0.904709, 6.82386e-05, 0.0052113, 0.0900108], 
              [0.00776787, 0.0257686, 0.0052113, 0.961252], 
              [0.909849, 6.82386e-05, 0.0129213, 0.0771611], 
              [0.688826, 6.82386e-05, 7.16287e-05, 0.311034], 
              [0.949681, 0.0079822, 0.0264498, 0.0158869], 
              [0.570605, 0.00520791, 0.113153, 0.311034], 
              [0.398413, 0.11315, 0.403567, 0.0848711], 
              [0.14398, 0.347023, 0.385576, 0.123421], 
              [0.213371, 0.377863, 0.329036, 0.0797314], 
              [0.210801, 0.326462, 0.329036, 0.133702], 
              [0.210801, 0.303332, 0.329036, 0.156832], 
              [0.17482, 0.275061, 0.357306, 0.192812], 
              [0.19795, 0.259641, 0.359876, 0.182532]
            ],
            "total_sites": 605,
            "sites": [
              0, 1, 1, 0, 2, 0, 5, 2, 0, 1, 1, 1, 2, 2, 1, 2, 2, 4, 0, 3, 1,
              3, 2, 5, 1, 1, 2, 0, 3, 1, 2, 2, 2, 1, 2, 1, 1, 2, 0, 1, 0, 1,
              1, 1, 1, 0, 1, 2, 1, 0, 1, 1, 0, 2, 1, 1, 0, 3, 1, 1, 1, 4, 0,
              1, 3, 1, 4, 2, 2, 6, 1, 0, 4, 3, 3, 4, 2, 2, 0, 0, 3, 6, 3, 0,
              0, 1, 1, 1, 2, 0, 1, 2, 1, 2, 2, 3, 2, 1, 1, 2, 1, 0, 1, 1, 3,
              1, 3, 2, 1, 4, 2, 0, 1, 0, 0, 1, 0, 2, 1, 0, 1, 1, 0, 0, 1, 1,
              0, 4, 3, 0, 1, 3, 1, 3, 0, 1, 2, 0, 1, 3, 3, 0, 2, 1, 2, 2, 3,
              1, 3, 1, 0, 3, 2, 2, 0, 1, 3, 4, 1, 1, 1, 0, 0, 1, 2, 2, 0, 3,
              1, 3, 1, 0, 1, 1, 0, 2, 1, 3, 1, 1, 2, 0, 3, 0, 3, 2, 0, 2, 1,
              3, 3, 3, 0, 3, 1, 0, 1, 2, 2, 1, 1, 0, 2, 1, 1, 2, 1, 2, 1, 1,
              0, 3, 6, 4, 1, 2, 5, 8, 3, 11, 12, 1, 4, 2, 4, 1, 2, 0, 1, 1, 2,
              1, 1, 0, 3, 3, 1, 0, 0, 3, 0, 1, 1, 0, 3, 0, 4, 1, 1, 0, 0, 1,
              1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0,
              0, 0, 1, 1, 0, 2, 3, 0, 1, 0, 1, 2, 0, 0, 3, 0, 2, 1, 2, 0, 0,
              0, 0, 4, 1, 1, 0, 3, 0, 2, 0, 0, 0, 0, 2, 1, 0, 0, 0, 1, 1, 2,
              0, 2, 1, 0, 0, 0, 0, 1, 1, 2, 1, 2, 1, 1, 2, 1, 0, 1, 1, 1, 0,
              0, 4, 2, 3, 2, 0, 0, 0, 0, 1, 0, 3, 0, 1, 1, 2, 1, 2, 0, 1, 0,
              1, 2, 1, 0, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 2,
              2, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1, 1, 0, 1, 0, 2, 1, 0, 0,
              3, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 2, 1, 1, 2, 4, 1, 0, 1,
              1, 0, 2, 1, 1, 1, 1, 1, 0, 2, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2,
              1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 2, 1, 0, 1, 0,
              3, 0, 1, 1, 1, 2, 0, 1, 2, 0, 1, 0, 1, 0, 1, 0, 0, 3, 1, 0, 0,
              1, 0, 2
            ],
            "seqs": [
              6, 19, 52, 56, 78, 85, 88, 89, 92, 118, 123, 129, 145, 199, 217,
              225, 226, 231, 243, 252, 263, 283, 291, 293, 295, 318, 330, 345,
              347, 352, 355, 361, 362, 379, 409, 448, 473, 508, 510, 513, 563,
              576, 591, 592, 601, 636, 655, 656, 669, 687, 720, 745, 774, 776,
              797, 834, 845, 852, 862, 866, 880, 916, 922, 962, 978, 983
            ],
            "peaks": [
              {
                "center": -25,
                "spread": 14,
                "sites": 66,
                "log_adj_pvalue": -32.3824
              }
            ]
          }, {
            "db": 0,
            "id": "UP00093_1",
            "alt": "Klf7_primary",
            "len": 16,
            "motif_evalue": "0.0e-000",
            "motif_nsites": 20,
            "n_tested": 117854,
            "score_threshold": 5.01128,
            "url": "http:\/\/the_brain.bwh.harvard.edu\/uniprobe\/details2?id=00093",
            "pwm": [
              [0.204614, 0.198684, 0.171749, 0.424953], 
              [0.167473, 0.296626, 0.246241, 0.289661], 
              [0.267117, 0.148582, 0.398074, 0.186226], 
              [0.54777, 0.0611852, 0.336806, 0.054239], 
              [0.0516106, 0.896853, 0.0234417, 0.0280957], 
              [0.0388335, 0.917071, 0.00970145, 0.0343943], 
              [0.409431, 0.5652, 0.0175691, 0.00779923], 
              [0.0105957, 0.978784, 0.00243777, 0.00818231], 
              [0.204393, 0.00239619, 0.746226, 0.0469843], 
              [0.00505239, 0.98489, 0.00419, 0.00586888], 
              [0.00535985, 0.985224, 0.00567259, 0.00374251], 
              [0.00386135, 0.926242, 0.00262085, 0.0672748], 
              [0.260154, 0.420903, 0.0259801, 0.292963], 
              [0.184996, 0.247782, 0.086196, 0.481026], 
              [0.346925, 0.19768, 0.140648, 0.314748], 
              [0.255128, 0.167109, 0.242475, 0.335289]
            ],
            "total_sites": 697,
            "sites": [
              1, 2, 1, 0, 0, 0, 0, 0, 2, 0, 3, 1, 2, 0, 1, 1, 1, 2, 0, 1, 3,
              2, 2, 0, 0, 2, 2, 0, 1, 0, 0, 0, 1, 0, 1, 2, 1, 1, 0, 2, 2, 1,
              1, 1, 1, 2, 1, 0, 1, 1, 1, 0, 4, 2, 0, 2, 0, 0, 0, 2, 3, 0, 2,
              0, 0, 0, 2, 1, 2, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 2, 2, 0, 0,
              2, 1, 1, 0, 1, 0, 1, 1, 4, 1, 0, 0, 0, 1, 0, 2, 1, 4, 1, 1, 2,
              3, 1, 2, 2, 1, 0, 3, 2, 2, 0, 0, 3, 1, 5, 5, 3, 2, 1, 5, 3, 1,
              4, 0, 2, 1, 2, 4, 1, 5, 0, 3, 0, 2, 4, 1, 3, 4, 2, 1, 1, 2, 2,
              2, 2, 2, 2, 3, 3, 3, 2, 5, 4, 7, 1, 1, 3, 4, 7, 3, 2, 0, 4, 0,
              3, 0, 4, 0, 0, 2, 4, 1, 1, 2, 3, 9, 4, 1, 1, 3, 3, 1, 4, 3, 1,
              3, 4, 3, 4, 2, 3, 2, 5, 3, 5, 3, 4, 4, 6, 1, 4, 0, 3, 2, 3, 1,
              3, 0, 2, 2, 1, 2, 0, 3, 3, 3, 1, 4, 1, 5, 1, 5, 2, 4, 2, 1, 1,
              2, 2, 3, 3, 2, 2, 1, 1, 1, 2, 1, 4, 2, 0, 3, 1, 1, 1, 2, 0, 1,
              1, 1, 1, 1, 1, 2, 0, 1, 5, 0, 1, 2, 1, 3, 0, 1, 0, 0, 1, 0, 1,
              1, 0, 1, 0, 2, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 2, 1, 2,
              0, 0, 0, 2, 1, 0, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0,
              1, 1, 0, 2, 2, 3, 1, 1, 0, 1, 0, 1, 1, 0, 2, 0, 0, 1, 1, 0, 0,
              1, 1, 2, 2, 2, 3, 1, 1, 0, 1, 0, 3, 0, 1, 0, 2, 1, 1, 2, 2, 1,
              1, 0, 2, 0, 2, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 3, 1, 0,
              1, 0, 1, 1, 0, 2, 2, 3, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
              2, 1, 0, 1, 2, 2, 1, 3, 2, 1, 4, 4, 1, 4, 2, 0, 1, 2, 0, 0, 2,
              0, 1, 2, 3, 0, 3, 2, 0, 1, 1, 1, 5, 0, 0, 1, 2, 0, 1, 2, 0, 1,
              2, 1, 0, 3, 1, 1, 1, 2, 0, 0, 1, 2, 2, 0, 1, 3, 2, 0, 0, 1, 0,
              1, 1, 1, 0, 0, 2, 0, 0, 1, 0, 3, 3, 3, 0, 1, 0, 2, 3, 2, 2, 0,
              1, 2
            ],
            "seqs": [
              1, 5, 6, 10, 14, 17, 23, 25, 29, 31, 37, 41, 47, 51, 52, 54, 57,
              67, 68, 70, 74, 76, 79, 82, 83, 85, 86, 88, 95, 98, 101, 102,
              103, 107, 108, 114, 116, 119, 121, 127, 129, 136, 139, 143, 145,
              151, 152, 154, 156, 159, 168, 173, 174, 175, 182, 190, 191, 192,
              196, 197, 200, 201, 209, 210, 218, 221, 222, 225, 226, 227, 229,
              232, 233, 235, 238, 239, 242, 243, 245, 248, 254, 255, 259, 261,
              266, 270, 272, 273, 279, 285, 295, 296, 300, 303, 305, 309, 310,
              311, 313, 314, 316, 321, 325, 328, 337, 340, 341, 342, 345, 347,
              348, 351, 362, 364, 365, 367, 368, 369, 371, 374, 375, 382, 384,
              386, 389, 390, 395, 398, 399, 403, 408, 412, 414, 418, 419, 422,
              423, 428, 431, 432, 434, 436, 437, 438, 442, 448, 450, 462, 464,
              465, 467, 469, 472, 475, 477, 478, 481, 482, 483, 484, 489, 495,
              497, 502, 503, 504, 511, 513, 519, 520, 526, 533, 538, 539, 540,
              542, 544, 549, 552, 554, 555, 560, 562, 563, 567, 568, 570, 571,
              573, 576, 577, 579, 580, 583, 587, 595, 596, 598, 600, 606, 607,
              614, 620, 623, 627, 629, 631, 632, 643, 644, 646, 649, 656, 658,
              660, 661, 663, 666, 667, 673, 675, 681, 682, 684, 692, 694, 697,
              698, 699, 701, 705, 710, 712, 713, 714, 716, 718, 721, 727, 728,
              741, 746, 756, 761, 762, 764, 769, 772, 773, 777, 782, 785, 794,
              802, 803, 805, 812, 815, 821, 823, 830, 832, 833, 837, 838, 839,
              842, 843, 845, 849, 851, 853, 857, 858, 861, 864, 869, 873, 875,
              876, 880, 881, 882, 885, 887, 889, 894, 896, 902, 904, 909, 914,
              919, 924, 925, 928, 929, 931, 935, 938, 939, 943, 944, 946, 947,
              948, 950, 952, 958, 961, 963, 969, 970, 972, 976, 979, 990, 993,
              994, 998
            ],
            "peaks": [
              {
                "center": -62.5,
                "spread": 128,
                "sites": 320,
                "log_adj_pvalue": -52.2808
              }
            ]
          }, {
            "db": 0,
            "id": "UP00020_1",
            "alt": "Atf1_primary",
            "len": 16,
            "motif_evalue": "0.0e-000",
            "motif_nsites": 20,
            "n_tested": 117854,
            "score_threshold": 5.04134,
            "url": "http:\/\/the_brain.bwh.harvard.edu\/uniprobe\/details2?id=00020",
            "pwm": [
              [0.380555, 0.135774, 0.245052, 0.238618], 
              [0.139961, 0.418849, 0.196075, 0.245116], 
              [0.158401, 0.0993206, 0.409317, 0.33296], 
              [0.471521, 0.097431, 0.387697, 0.0433495], 
              [0.00994095, 0.0299852, 0.00668851, 0.953386], 
              [0.0151489, 0.0155156, 0.860563, 0.108772], 
              [0.958922, 0.00594743, 0.0131403, 0.0219903], 
              [0.00419269, 0.945695, 0.00453229, 0.0455813], 
              [0.0455409, 0.00446684, 0.94576, 0.00423306], 
              [0.0219499, 0.0130748, 0.00601289, 0.958962], 
              [0.108732, 0.860498, 0.015581, 0.0151893], 
              [0.953346, 0.00662305, 0.0300507, 0.00998132], 
              [0.0506305, 0.3574, 0.145489, 0.446481], 
              [0.225763, 0.447519, 0.143015, 0.183705], 
              [0.264566, 0.0984589, 0.491961, 0.145014], 
              [0.351683, 0.1807, 0.236972, 0.230645]
            ],
            "total_sites": 270,
            "sites": [
              1, 1, 0, 1, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1,
              1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 2, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0,
              0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 2,
              0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 2, 1,
              1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 2, 1, 0, 1, 0, 0, 0, 1, 1,
              0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0,
              1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 2, 0, 1, 1, 0, 1, 0, 2, 2, 0, 1,
              0, 0, 1, 0, 1, 2, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 2, 1, 1, 0, 1,
              1, 2, 1, 2, 0, 0, 0, 1, 1, 1, 1, 2, 2, 0, 3, 1, 0, 1, 3, 2, 1,
              1, 2, 0, 3, 3, 1, 1, 0, 0, 3, 0, 2, 1, 1, 0, 2, 0, 1, 0, 0, 3,
              1, 1, 0, 0, 2, 3, 0, 0, 2, 0, 1, 2, 0, 4, 2, 0, 0, 0, 0, 2, 0,
              4, 2, 0, 0, 0, 1, 3, 0, 2, 0, 0, 2, 0, 1, 2, 0, 1, 0, 0, 0, 0,
              0, 0, 2, 0, 0, 2, 1, 1, 0, 0, 0, 2, 0, 0, 2, 0, 0, 1, 1, 0, 0,
              0, 0, 1, 0, 1, 4, 0, 0, 1, 0, 1, 0, 1, 0, 2, 0, 0, 0, 0, 1, 1,
              0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0,
              0, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1,
              0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0,
              1, 0, 0, 0, 0, 2, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 2, 0, 0, 2, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
              1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
              1, 0, 0, 0, 2, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0,
              2, 0
            ],
            "seqs": [
              14, 15, 18, 19, 24, 51, 54, 59, 60, 73, 82, 89, 93, 111, 122,
              127, 133, 134, 146, 154, 173, 174, 176, 177, 180, 189, 191, 193,
              201, 206, 209, 243, 278, 305, 309, 316, 319, 322, 324, 341, 343,
              345, 346, 349, 351, 364, 393, 402, 428, 429, 438, 442, 445, 446,
              448, 453, 460, 467, 471, 473, 474, 476, 483, 490, 492, 502, 503,
              524, 530, 532, 538, 554, 560, 563, 565, 574, 575, 588, 595, 597,
              608, 622, 624, 630, 655, 665, 668, 687, 696, 700, 705, 737, 760,
              771, 779, 781, 785, 808, 813, 827, 843, 854, 861, 869, 872, 874,
              906, 954, 956, 963, 985, 986
            ],
            "peaks": [
              {
                "center": -52.5,
                "spread": 112,
                "sites": 112,
                "log_adj_pvalue": -13.224
              }
            ]
          }, {
            "db": 0,
            "id": "UP00002_2",
            "alt": "Sp4_secondary",
            "len": 15,
            "motif_evalue": "0.0e-000",
            "motif_nsites": 20,
            "n_tested": 118340,
            "score_threshold": 5.0257,
            "url": "http:\/\/the_brain.bwh.harvard.edu\/uniprobe\/details2?id=00002",
            "pwm": [
              [0.146723, 0.31209, 0.244449, 0.29674], 
              [0.491819, 0.0934658, 0.163081, 0.251634], 
              [0.502205, 0.0608828, 0.0785582, 0.358355], 
              [0.76064, 0.0165056, 0.213437, 0.00941714], 
              [0.0134703, 0.0271206, 0.942181, 0.0172281], 
              [0.00779667, 0.0164629, 0.946754, 0.0289863], 
              [0.0632215, 0.83147, 0.0556119, 0.0496967], 
              [0.0120723, 0.0218917, 0.925583, 0.040454], 
              [0.0138385, 0.0253594, 0.14648, 0.814323], 
              [0.134047, 0.0351106, 0.785339, 0.0455027], 
              [0.141114, 0.180901, 0.427505, 0.250481], 
              [0.0372176, 0.803718, 0.0347263, 0.124339], 
              [0.158241, 0.407892, 0.123201, 0.310665], 
              [0.291848, 0.260041, 0.197915, 0.250195], 
              [0.250975, 0.125178, 0.359042, 0.264806]
            ],
            "total_sites": 784,
            "sites": [
              2, 1, 1, 3, 2, 1, 0, 0, 1, 2, 2, 2, 1, 0, 1, 0, 0, 2, 2, 3, 3,
              3, 1, 2, 1, 0, 0, 3, 0, 0, 1, 0, 1, 2, 0, 2, 2, 0, 1, 0, 1, 2,
              1, 0, 0, 1, 3, 1, 0, 2, 0, 5, 2, 2, 5, 1, 4, 2, 2, 2, 1, 2, 2,
              3, 1, 2, 3, 1, 2, 1, 0, 0, 0, 3, 2, 1, 1, 1, 0, 0, 2, 1, 2, 0,
              1, 2, 6, 2, 0, 3, 0, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 1,
              0, 2, 2, 5, 1, 1, 3, 2, 3, 2, 2, 1, 1, 7, 2, 3, 3, 1, 1, 4, 2,
              4, 3, 2, 0, 4, 0, 0, 3, 1, 0, 0, 1, 6, 4, 0, 4, 2, 2, 4, 3, 0,
              3, 3, 2, 4, 1, 2, 2, 0, 2, 4, 1, 0, 1, 1, 2, 0, 3, 1, 3, 2, 1,
              2, 1, 2, 0, 1, 1, 0, 4, 3, 1, 3, 2, 3, 3, 1, 3, 1, 3, 1, 2, 3,
              3, 2, 4, 2, 3, 2, 1, 3, 3, 2, 4, 5, 5, 3, 0, 4, 2, 2, 2, 3, 3,
              2, 1, 0, 2, 1, 1, 3, 2, 3, 3, 2, 1, 4, 2, 2, 2, 1, 3, 1, 2, 2,
              1, 3, 5, 3, 3, 2, 2, 1, 1, 0, 2, 2, 2, 1, 1, 1, 1, 0, 0, 3, 2,
              1, 0, 1, 2, 1, 3, 1, 1, 3, 2, 0, 0, 0, 1, 0, 3, 0, 1, 1, 1, 1,
              0, 1, 0, 0, 0, 1, 2, 0, 0, 2, 0, 1, 1, 0, 0, 0, 2, 1, 3, 3, 1,
              3, 1, 1, 2, 1, 0, 2, 1, 0, 0, 1, 1, 2, 3, 2, 2, 2, 0, 2, 4, 1,
              0, 1, 0, 1, 1, 3, 1, 2, 1, 3, 1, 0, 2, 0, 2, 1, 0, 1, 1, 4, 0,
              2, 3, 1, 3, 0, 0, 3, 1, 1, 1, 1, 2, 0, 1, 0, 3, 1, 0, 4, 1, 5,
              2, 1, 2, 1, 3, 2, 0, 1, 0, 1, 0, 0, 0, 0, 2, 5, 0, 3, 1, 1, 1,
              2, 0, 1, 1, 0, 3, 3, 3, 1, 3, 2, 0, 2, 1, 0, 1, 1, 2, 3, 1, 1,
              0, 1, 1, 2, 1, 2, 1, 3, 1, 4, 3, 1, 3, 8, 1, 2, 1, 0, 1, 1, 4,
              0, 2, 3, 1, 0, 2, 3, 1, 2, 3, 1, 3, 1, 1, 2, 3, 1, 2, 1, 0, 0,
              3, 2, 3, 2, 6, 1, 3, 1, 0, 1, 1, 3, 1, 0, 0, 3, 1, 2, 1, 0, 3,
              0, 1, 2, 2, 0, 0, 2, 0, 0, 0, 1, 3, 2, 3, 0, 1, 2, 0, 2, 6, 0,
              1, 0, 4
            ],
            "seqs": [
              1, 2, 9, 10, 23, 27, 29, 30, 31, 33, 38, 41, 42, 47, 53, 54, 57,
              58, 68, 70, 73, 74, 79, 82, 83, 85, 86, 88, 92, 93, 98, 99, 101,
              103, 107, 108, 112, 116, 119, 121, 125, 126, 127, 129, 139, 143,
              145, 146, 148, 150, 151, 153, 154, 156, 159, 160, 161, 162, 166,
              168, 171, 173, 174, 176, 192, 196, 197, 200, 203, 209, 210, 213,
              215, 219, 224, 225, 227, 233, 237, 238, 239, 242, 243, 245, 248,
              250, 255, 256, 261, 262, 263, 266, 267, 268, 270, 273, 275, 277,
              280, 284, 285, 286, 292, 297, 306, 309, 310, 311, 323, 325, 328,
              331, 336, 340, 345, 348, 354, 355, 365, 371, 375, 383, 384, 386,
              389, 390, 398, 403, 405, 408, 412, 414, 418, 422, 423, 424, 431,
              432, 433, 434, 435, 436, 448, 450, 455, 462, 464, 469, 472, 477,
              479, 483, 485, 489, 497, 504, 511, 513, 517, 518, 520, 521, 533,
              539, 543, 550, 553, 556, 557, 563, 573, 580, 595, 598, 604, 605,
              606, 607, 611, 612, 614, 620, 623, 629, 631, 633, 637, 643, 644,
              646, 647, 653, 656, 661, 666, 667, 673, 675, 677, 681, 683, 684,
              685, 694, 698, 705, 708, 709, 712, 714, 715, 716, 721, 725, 727,
              737, 740, 741, 746, 747, 750, 751, 756, 760, 761, 762, 764, 772,
              778, 779, 782, 785, 794, 796, 798, 802, 803, 805, 812, 818, 821,
              830, 832, 843, 845, 849, 851, 855, 857, 858, 860, 869, 873, 875,
              878, 880, 881, 885, 897, 902, 904, 907, 908, 909, 910, 919, 920,
              922, 924, 925, 926, 928, 931, 935, 938, 939, 943, 946, 953, 960,
              961, 966, 969, 972, 973, 974, 976, 981, 983, 984, 986, 990, 994,
              997, 998
            ],
            "peaks": [
              {
                "center": -73.5,
                "spread": 137,
                "sites": 295,
                "log_adj_pvalue": -7.10675
              }
            ]
          }, {
            "db": 0,
            "id": "MA0060.1",
            "alt": "NFYA",
            "len": 16,
            "motif_evalue": "0.0e-000",
            "motif_nsites": 116,
            "n_tested": 117854,
            "score_threshold": 5.04127,
            "url": "http:\/\/jaspar.genereg.net\/cgi-bin\/jaspar_db.pl?ID=MA0060.1&rm=present&collection=CORE",
            "pwm": [
              [0.293044, 0.318919, 0.232798, 0.155239], 
              [0.138006, 0.284466, 0.224184, 0.353344], 
              [0.0604864, 0.439504, 0.215571, 0.284438], 
              [0.499763, 0.120814, 0.353383, 0.0260401], 
              [0.43947, 0.0346814, 0.482583, 0.0432663], 
              [0.000193394, 0.999367, 0.000239441, 0.000200383], 
              [0.0174195, 0.973527, 0.00885302, 0.000200383], 
              [0.964879, 0.000228108, 0.00885302, 0.0260401], 
              [0.999332, 0.000228108, 0.000239441, 0.000200383], 
              [0.000193394, 0.00884168, 0.000239441, 0.990725], 
              [0.120779, 0.56009, 0.284477, 0.0346537], 
              [0.568669, 0.0519076, 0.361997, 0.0174265], 
              [0.112166, 0.172494, 0.629007, 0.0863331], 
              [0.336111, 0.370599, 0.189731, 0.103559], 
              [0.310271, 0.0777473, 0.405062, 0.206919], 
              [0.215525, 0.301692, 0.250024, 0.232759]
            ],
            "total_sites": 397,
            "sites": [
              0, 1, 2, 2, 0, 0, 1, 2, 0, 0, 1, 2, 1, 0, 0, 1, 1, 1, 0, 0, 1,
              0, 0, 1, 2, 1, 0, 3, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 2, 0, 1, 1,
              0, 0, 0, 2, 0, 1, 1, 0, 1, 1, 1, 0, 1, 3, 1, 0, 0, 1, 1, 0, 1,
              0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 2, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0,
              1, 0, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 1, 0, 0, 2, 1, 1, 1, 0, 0,
              1, 2, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 2, 2,
              0, 0, 1, 0, 1, 0, 2, 2, 0, 0, 2, 1, 0, 2, 1, 2, 1, 1, 1, 1, 1,
              2, 3, 4, 1, 1, 1, 0, 2, 5, 0, 1, 3, 0, 1, 3, 5, 0, 4, 1, 2, 1,
              2, 2, 2, 3, 2, 0, 1, 3, 2, 1, 2, 4, 4, 2, 0, 0, 2, 1, 1, 2, 1,
              1, 4, 2, 0, 1, 2, 3, 0, 4, 1, 3, 1, 3, 0, 0, 3, 1, 2, 2, 2, 0,
              3, 0, 1, 1, 1, 0, 4, 2, 2, 1, 2, 3, 2, 0, 2, 2, 0, 2, 1, 0, 1,
              0, 1, 1, 0, 2, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
              1, 0, 0, 1, 2, 0, 0, 2, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1,
              2, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 0, 0, 2, 1, 3, 1, 0,
              1, 2, 0, 1, 1, 1, 0, 0, 2, 0, 1, 1, 0, 0, 0, 0, 1, 0, 2, 1, 2,
              3, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 1, 2, 0,
              0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0,
              0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0,
              0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0, 0, 2, 1, 0, 1, 0, 0,
              0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 2, 0, 0, 0,
              0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0,
              0, 2, 2, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0,
              1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 1, 1, 0, 1, 1, 1, 1, 2, 0,
              1, 0
            ],
            "seqs": [
              2, 4, 19, 28, 46, 55, 56, 78, 80, 91, 102, 107, 112, 113, 114,
              116, 117, 118, 123, 127, 143, 157, 183, 195, 198, 201, 203, 210,
              211, 215, 239, 242, 264, 273, 291, 293, 298, 303, 304, 314, 323,
              333, 342, 346, 357, 361, 362, 369, 370, 376, 380, 386, 397, 399,
              408, 412, 420, 425, 429, 435, 437, 441, 445, 446, 455, 456, 471,
              476, 481, 483, 508, 509, 510, 511, 516, 526, 540, 541, 542, 550,
              552, 553, 560, 561, 566, 568, 569, 579, 596, 597, 601, 602, 605,
              630, 631, 638, 646, 649, 650, 660, 661, 667, 669, 680, 699, 700,
              705, 716, 721, 722, 741, 746, 749, 750, 754, 760, 763, 783, 807,
              823, 825, 833, 835, 837, 849, 851, 852, 855, 858, 861, 863, 875,
              880, 896, 898, 899, 901, 902, 924, 925, 926, 939, 954, 976, 990,
              994, 995, 998
            ],
            "peaks": [
              {
                "center": -60,
                "spread": 87,
                "sites": 148,
                "log_adj_pvalue": -32.3933
              }
            ]
          }
        ]
      };
    </script>
    <script type="text/javascript">
var site_url = "http://vm2.ucsd.edu:8080/meme";

    </script>
    <script type="text/javascript">
/*
 * $
 *
 * Shorthand function for getElementById
 */
function $(el) {
  return document.getElementById(el);
}

/*
 * coords
 *
 * Calculates the x and y offset of an element.
 * From http://www.quirksmode.org/js/findpos.html
 * with alterations to take into account scrolling regions
 */
function coords(elem) {
  var myX = myY = 0;
  if (elem.getBoundingClientRect) {
    var rect;
    rect = elem.getBoundingClientRect();
    myX = rect.left + ((typeof window.pageXOffset !== "undefined") ?
        window.pageXOffset : document.body.scrollLeft);
    myY = rect.top + ((typeof window.pageYOffset !== "undefined") ?
        window.pageYOffset : document.body.scrollTop);
  } else {
    // this fall back doesn't properly handle absolutely positioned elements
    // inside a scrollable box
    var node;
    if (elem.offsetParent) {
      // subtract all scrolling
      node = elem;
      do {
        myX -= node.scrollLeft ? node.scrollLeft : 0;
        myY -= node.scrollTop ? node.scrollTop : 0;
      } while (node = node.parentNode);
      // this will include the page scrolling (which is unwanted) so add it back on
      myX += (typeof window.pageXOffset !== "undefined") ? window.pageXOffset : document.body.scrollLeft;
      myY += (typeof window.pageYOffset !== "undefined") ? window.pageYOffset : document.body.scrollTop;
      // sum up offsets
      node = elem;
      do {
        myX += node.offsetLeft;
        myY += node.offsetTop;
      } while (node = node.offsetParent);
    }
  }
  return [myX, myY];
}

/*
 * position_popup
 *
 * Positions a popup relative to an anchor element.
 *
 * The avaliable positions are:
 * 0 - Centered below the anchor.
 */
function position_popup(anchor, popup, position) {
  "use strict";
  var a_x, a_y, a_w, a_h, p_x, p_y, p_w, p_h;
  var a_xy, spacer, margin, scrollbar, page_w;
  // define constants
  spacer = 5;
  margin = 15;
  scrollbar = 15;
  // define the positions and widths
  a_xy = coords(anchor);
  a_x = a_xy[0];
  a_y = a_xy[1];
  a_w = anchor.offsetWidth;
  a_h = anchor.offsetHeight;
  p_w = popup.offsetWidth;
  p_h = popup.offsetHeight;
  page_w = null;
  if (window.innerWidth) {
    page_w = window.innerWidth;
  } else if (document.body) {
    page_w = document.body.clientWidth;
  }
  // check the position type is defined
  if (typeof position !== "undefined") {
    position = 0;
  }
  // calculate the popup position
  switch (position) {
    case 0:
    default:
      p_x = a_x + (a_w / 2) - (p_w / 2);
      p_y = a_y + a_h + spacer;
      break;
  }
  // constrain the popup position
  if (p_x < margin) {
    p_x = margin;
  } else if (page_w != null && (p_x + p_w) > (page_w - margin - scrollbar)) {
    p_x = page_w - margin - scrollbar - p_w;
  }
  if (p_y < margin) {
    p_y = margin;
  }
  // position the popup
  popup.style.left = p_x + "px";
  popup.style.top = p_y + "px";
}

/*
 * help_popup
 *
 * Moves around help pop-ups so they appear
 * below an activator.
 */
function help_popup(activator, popup_id) {
  // set default values
  if (typeof help_popup.popup === "undefined") {
    help_popup.popup = null;
  }
  if (typeof help_popup.activator === "undefined") {
    help_popup.activator = null;
  }
  if (typeof(activator) == "undefined") { // no activator so hide
    if (help_popup.popup) {
      help_popup.popup.style.display = 'none';
      help_popup.popup = null;
    }
    return;
  }
  var pop = $(popup_id);
  if (pop == help_popup.popup) {
    if (activator == help_popup.activator) {
      //hide popup (as we've already shown it for the current help button)
      help_popup.popup.style.display = 'none';
      help_popup.popup = null;
      return; // toggling complete!
    }
  } else if (help_popup.popup != null) {
    //activating different popup so hide current one
    help_popup.popup.style.display = 'none';
  }
  help_popup.popup = pop;
  help_popup.activator = activator;

  //must make the popup visible to measure it or it has zero width
  pop.style.display = 'block';
  position_popup(activator, pop);
}

/*
 * update_scroll_pad
 *
 * Creates padding at the bottom of the page to allow
 * scrolling of anything into view.
 */
function update_scroll_pad() {
  var page, pad;
  page = (document.compatMode === "CSS1Compat") ? document.documentElement : document.body;
  pad = $("scrollpad");
  if (pad === null) {
    pad = document.createElement("div");
    pad.id = 'scrollpad';
    document.getElementsByTagName('body')[0].appendChild(pad);
  }
  pad.style.height = Math.abs(page.clientHeight - 100) + "px";
}


/*
 * toggle_class
 *
 * Adds or removes a class from the node. If the parameter 'enabled' is not 
 * passed then the existence of the class will be toggled, otherwise it will be
 * included if enabled is true.
 */
function toggle_class(node, cls, enabled) {
  var classes = node.className;
  var list = classes.replace(/^\s+/, '').replace(/\s+$/, '').split(/\s+/);
  var found = false;
  for (var i = 0; i < list.length; i++) {
    if (list[i] == cls) {
      list.splice(i, 1);
      i--;
      found = true;
    }
  }
  if (enabled === undefined) {
    if (!found) list.push(cls);
  } else {
    if (enabled) list.push(cls);
  }
  node.className = list.join(" ");
}

/*
 * find_child
 *
 * Searches child nodes in depth first order and returns the first it finds
 * with the className specified.
 */
function find_child(node, className) {
  var pattern;
  if (typeof node !== "object") {
    return null;
  }
  if (typeof className === "string") {
    pattern = new RegExp("\\b" + className + "\\b");
  } else {
    pattern = className;
  }
  if (node.nodeType == Node.ELEMENT_NODE && 
      pattern.test(node.className)) {
    return node;
  } else {
    var result = null;
    for (var i = 0; i < node.childNodes.length; i++) {
      result = find_child(node.childNodes[i], pattern);
      if (result != null) break;
    }
    return result;
  }
}

/*
 * find_parent
 *
 * Searches parent nodes outwards from the node and returns the first it finds
 * with the className specified.
 */
function find_parent(node, className) {
  var pattern;
  pattern = new RegExp("\\b" + className + "\\b");
  do {
    if (node.nodeType == Node.ELEMENT_NODE && 
        pattern.test(node.className)) {
      return node;
    }
  } while (node = node.parentNode);
  return null;
}

/*
 * __toggle_help
 *
 * Uses the 'topic' property of the this object to
 * toggle display of a help topic.
 *
 * This function is not intended to be called directly.
 */
function __toggle_help(e) {
  if (!e) e = window.event;
  if (e.type === "keydown") {
    if (e.keyCode !== 13 && e.keyCode !== 32) {
      return;
    }
    // stop a submit or something like that
    e.preventDefault();
  }

  help_popup(this, this.topic);
}

/*
 * help_button
 *
 * Makes a help button for the passed topic.
 */
function help_button(topic) {
  var btn = document.createElement("div");
  btn.className = "help";
  btn.topic = topic;
  btn.tabIndex = "0";
  btn.addEventListener("click", __toggle_help, false);
  btn.addEventListener("keydown", __toggle_help, false);
  return btn;
}

/*
 * add_cell
 *
 * Add a cell to the table row.
 */
function add_cell(row, node, cls, click_action) {
  var cell = row.insertCell(row.cells.length);
  if (node) cell.appendChild(node);
  if (cls && cls !== "") cell.className = cls;
  if (click_action) cell.onclick = click_action;
}

/*
 * add_cell
 *
 * Add a header cell to the table row.
 */
function add_header_cell(row, node, help_topic, cls) {
  var th = document.createElement("th");
  row.appendChild(th);
  if (node) th.appendChild(node);
  if (help_topic && help_topic !== "") th.appendChild(help_button(help_topic));
  if (cls && cls !== "") th.className = cls;
}

/*
 * add_text_cell
 *
 * Add a text cell to the table row.
 */
function add_text_cell(row, text, cls, click_action) {
  var node = null;
  if (typeof(text) != 'undefined') node = document.createTextNode(text);
  add_cell(row, node, cls, click_action);
}

/*
 * add_text_header_cell
 *
 * Add a text header cell to the table row.
 */
function add_text_header_cell(row, text, help_topic, cls) {
  var node = null;
  if (typeof(text) != 'undefined') {
    var nbsp = (help_topic ? "\u00A0" : "");
    var str = "" + text;
    var parts = str.split(/\n/);
    if (parts.length === 1) {
      node = document.createTextNode(str + nbsp);
    } else {
      node = document.createElement("span");
      for (var i = 0; i < parts.length; i++) {
        if (i !== 0) {
          node.appendChild(document.createElement("br"));
        }
        node.appendChild(document.createTextNode(parts[i]));
      }
    }
  }
  add_header_cell(row, node, help_topic, cls);
}

    </script>
    <script type="text/javascript">
function rad2deg(rad) {
  return rad * 180 / Math.PI;
}

function parse_line_join(line_join) {
  line_join = line_join.toLowerCase();
  if (line_join == "bevel") {
    return 2;
  } else if (line_join == "round") {
    return 1;
  } else { // miter
    return 0;
  }
}

function parse_line_cap(line_cap) {
  line_cap = line_cap.toLowerCase();
  if (line_cap == "square") {
    return 2;
  } else if (line_cap == "round") {
    return 1;
  } else { // butt 
    return 0;
  }
}

function parse_text_align(text_align) {
  text_align = text_align.toLowerCase();
  if (text_align == "center") {
    return "center";
  } else if (text_align == "end" || text_align == "right") {
    return "right"; 
  } else { // start or left
    return "left";
  }
}

function parse_text_baseline(text_baseline) {
  text_baseline = text_baseline.toLowerCase();
  if (text_baseline == "top" || text_baseline == "hanging") {
    return "top";
  } else if (text_baseline == "middle") {
    return "middle";
  } else if (text_baseline == "bottom") {
    return "bottom";
  } else { // alphabetic or ideographic
    return "alphabetic";
  }
}

function parse_colour(colour) {
  var hex6_re = /^#([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/;
  var hex3_re = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/;
  var rgb_re = /^\s*rgb\s*\(\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*\)\s*$/;
  var rgba_re = /^\s*rgba\s*\(\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*\)\s*$/;
  if (colour === undefined || colour == "") {
    return {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  }
  colour = colour.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); //trim
  colour = colour.toLowerCase();
  if (colour == "maroon") {// #800000
    return {'red': 128, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "red") { // #FF0000
    return {'red': 255, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "orange") { // FFA500
    return {'red': 255, 'green': 165, 'blue': 0, 'alpha': 255};
  } else if (colour == "yellow") { // #FFFF00
    return {'red': 255, 'green': 255, 'blue': 0, 'alpha': 255};
  } else if (colour == "olive") { // #808000
    return {'red': 128, 'green': 128, 'blue': 0, 'alpha': 255};
  } else if (colour == "purple") { // #800080
    return {'red': 128, 'green': 0, 'blue': 128, 'alpha': 255};
  } else if (colour == "fuchsia" || colour == "magenta") { // #FF00FF
    return {'red': 255, 'green': 0, 'blue': 255, 'alpha': 255};
  } else if (colour == "white") { // #FFFFFF
    return {'red': 255, 'green': 255, 'blue': 255, 'alpha': 255};
  } else if (colour == "lime") { // #00FF00
    return {'red': 0, 'green': 255, 'blue': 0, 'alpha': 255};
  } else if (colour == "green") { // #008000
    return {'red': 0, 'green': 128, 'blue': 0, 'alpha': 255};
  } else if (colour == "navy") { // #000080
    return {'red': 0, 'green': 0, 'blue': 128, 'alpha': 255};
  } else if (colour == "blue") { // #0000FF
    return {'red': 0, 'green': 0, 'blue': 255, 'alpha': 255};
  } else if (colour == "aqua" || colour == "cyan") { // #00FFFF
    return {'red': 0, 'green': 255, 'blue': 255, 'alpha': 255};
  } else if (colour == "teal") { // #008080
    return {'red': 0, 'green': 128, 'blue': 128, 'alpha': 255};
  } else if (colour == "black") { // #000000
    return {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "silver") { // #C0C0C0
    return {'red': 192, 'green': 192, 'blue': 192, 'alpha': 255};
  } else if (colour == "gray") { // #808080
    return {'red': 128, 'green': 128, 'blue': 128, 'alpha': 255};
  }
  var matches;
  matches = hex6_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1], 16);
    var green = parseInt(matches[2], 16);
    var blue = parseInt(matches[3], 16);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = hex3_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1] + matches[1], 16);
    var green = parseInt(matches[2] + matches[2], 16);
    var blue = parseInt(matches[3] + matches[3], 16);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = rgb_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1]);
    if (matches[2] == "%") red = Math.round((red * 255) / 100);
    var green = parseInt(matches[3]);
    if (matches[4] == "%") green = Math.round((green * 255) / 100);
    var blue = parseInt(matches[5]);
    if (matches[6] == "%") blue = Math.round((blue * 255) / 100);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = rgba_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1]);
    if (matches[2] == "%") red = Math.round((red * 255) / 100);
    var green = parseInt(matches[3]);
    if (matches[4] == "%") green = Math.round((green * 255) / 100);
    var blue = parseInt(matches[5]);
    if (matches[6] == "%") blue = Math.round((blue * 255) / 100);
    var alpha = parseInt(matches[7]);
    if (matches[8] == "%") alpha = Math.round((alpha * 255) / 100);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': alpha};
  }
  // default to black
  throw new Error("Failed to parse colour: " + colour);
}

function colour_equals(colour1, colour2) {
  if (colour1.red != colour2.red) return false;
  if (colour1.green != colour2.green) return false;
  if (colour1.blue != colour2.blue) return false;
  if (colour1.alpha != colour2.alpha) return false;
  return true;
}

// splits a font string into words
function split_words(str) {
  var words = [];
  var start = -1;
  var space = /\s/;
  var single_quote = false;
  var double_quote = false;
  // read words
  for (var i = 0; i < str.length; i++) {
    if (start == -1) {
      if (!space.test(str.charAt(i))) {
        switch (str.charAt(i)) {
          case "'":
            single_quote = true;
            start = i + 1;
            break;
          case '"':
            double_quote = true;
            start = i + 1;
            break;
          default:
            start = i;
        }
      }
    } else {
      if (!single_quote && !double_quote) {
        if (space.test(str.charAt(i))) {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
        } else if (str.charAt(i) == "'" || str.charAt(i) == '"') {
          throw new Error("Quote in the middle of an unquoted word!");
        }
      } else if (single_quote) {
        if (str.charAt(i) == "'") {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
          single_quote = false;
        }
      } else if (double_quote) {
        if (str.charAt(i) == '"') {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
          double_quote = false;
        }
      }
    }
  }
  if (start != -1) {
    if (single_quote || double_quote) throw new Error("Unterminated quoted region");
    words.push(str.substr(start));
  }
  return words;
}

function add_intercepts(ctx2d, eps_callback) {
  ctx2d.eps_callback = eps_callback;
  ctx2d.save = function() {
    this.eps_callback.save();
    Object.getPrototypeOf(this).save.call(this);
  };
  ctx2d.restore = function() {
    this.eps_callback.restore();
    Object.getPrototypeOf(this).restore.call(this);
  };
  ctx2d.beginPath = function() {
    this.eps_callback.beginPath();
    Object.getPrototypeOf(this).beginPath.call(this);
  };
  ctx2d.closePath = function() {
    this.eps_callback.closePath();
    Object.getPrototypeOf(this).closePath.call(this);
  };
  ctx2d.moveTo = function(x, y) {
    this.eps_callback.moveTo(x, y);
    Object.getPrototypeOf(this).moveTo.call(this, x, y);
  };
  ctx2d.lineTo = function(x, y) {
    this.eps_callback.lineTo(x, y);
    Object.getPrototypeOf(this).lineTo.call(this, x, y);
  };
  ctx2d.rect = function(x, y, w, h) {
    this.eps_callback.rect(x, y, w, h);
    Object.getPrototypeOf(this).rect.call(this, x, y, w, h);
  };
  ctx2d.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.eps_callback.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    Object.getPrototypeOf(this).arc.call(this, x, y, radius, startAngle, endAngle, anticlockwise);
  };
  ctx2d.arcTo = function(cpx1, cpy1, cpx2, cpy2, radius) {
    this.eps_callback.arcTo(cpx1, cpy1, cpx2, cpy2, radius);
    Object.getPrototypeOf(this).arcTo.call(this, cpx1, cpy1, cpx2, cpy2, radius);
  };
  ctx2d.quadraticArcTo = function(cpx, cpy, x, y) {
    this.eps_callback.quadraticArcTo(cpx, cpy, x, y);
    Object.getPrototypeOf(this).quadraticArcTo.call(this, cpx, cpy, x, y);
  };
  ctx2d.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.eps_callback.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    Object.getPrototypeOf(this).bezierCurveTo.call(this, cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx2d.stroke = function() {
    this.eps_callback.stroke();
    Object.getPrototypeOf(this).stroke.call(this);
  };
  ctx2d.fill = function() {
    this.eps_callback.fill();
    Object.getPrototypeOf(this).fill.call(this);
  };
  ctx2d.clip = function() {
    this.eps_callback.clip();
    Object.getPrototypeOf(this).clip.call(this);
  };
  ctx2d.fillRect = function(x, y, width, height) {
    this.eps_callback.fillRect(x, y, width, height);
    Object.getPrototypeOf(this).fillRect.call(this, x, y, width, height);
  };
  ctx2d.strokeRect = function(x, y, width, height) {
    this.eps_callback.strokeRect(x, y, width, height);
    Object.getPrototypeOf(this).strokeRect.call(this, x, y, width, height);
  };
  ctx2d.clearRect = function(x, y, width, height) {
    this.eps_callback.clearRect(x, y, width, height);
    Object.getPrototypeOf(this).clearRect.call(this, x, y, width, height);
  };
  ctx2d.fillText = function(string, x, y) {
    this.eps_callback.fillText(string, x, y);
    Object.getPrototypeOf(this).fillText.call(this, string, x, y);
  };
  ctx2d.translate = function(dx, dy) {
    this.eps_callback.translate(dx, dy);
    Object.getPrototypeOf(this).translate.call(this, dx, dy);
  };
  ctx2d.rotate = function(angle) {
    this.eps_callback.rotate(angle);
    Object.getPrototypeOf(this).rotate.call(this, angle);
  };
  ctx2d.scale = function(sx, sy) {
    this.eps_callback.scale(sx, sy);
    Object.getPrototypeOf(this).scale.call(this, sx, sy);
  };
  ctx2d.transform = function(m11, m12, m21, m22, dx, dy) {
    this.eps_callback.transform(m11, m12, m21, m22, dx, dy);
    Object.getPrototypeOf(this).transform.call(this, m11, m12, m21, m22, dx, dy);
  };
  ctx2d.setTransform = function(m11, m12, m21, m22, dx, dy) {
    this.eps_callback.setTransform(m11, m12, m21, m22, dx, dy);
    Object.getPrototypeOf(this).setTransform.call(this, m11, m12, m21, m22, dx, dy);
  };
}

var EpsState = function(copy) {
  // canvas vars
  this.activeStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.fillStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.strokeStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.lineWidth = 1.0;
  this.lineCap = 0;
  this.lineJoin = 0;
  this.miterLimit = 10.0;
  this.font = undefined;
  this.textAlign = "left";
  this.textBaseline = "alphabetic";
  if (copy) {
    this.activeStyle = copy.activeStyle;
    this.fillStyle = copy.fillStyle;
    this.strokeStyle = copy.strokeStyle;
    this.lineWidth = copy.lineWidth;
    this.lineCap = copy.lineCap;
    this.lineJoin = copy.lineJoin;
    this.miterLimit = copy.miterLimit;
    this.font = copy.font;
    this.textAlign = copy.textAlign;
    this.textBaseline = copy.textBaseline;
  }
};


var EpsContext = function(ctx, width, height) {
  var title = "Image Title";
  var creator = "Image Creator";
  var date = new Date();
  // private parameters
  this.ctx = ctx;
  this.width = width;
  this.height = height;
  this.stack = [];
  this.current_state = new EpsState();
  this.font_lookup = {};
  this.indent = "";
  this.eps_text = 
    "%!PS-Adobe-3.0 EPSF-3.0\n" + 
    "%%Title: " + title + "\n" + 
    "%%Creator: " + creator + "\n" +
    "%%CreationDate: " + date.toUTCString() + "\n" + 
    "%%BoundingBox: 0 0 " + (width * 0.75) + " " + (height * 0.75) + "\n" +
    "%%Pages: 0\n" +
    "%%DocumentFonts:\n" +
    "%%EndComments\n" +
    "0.75 0.75 scale\n" +
    "0 " + height + " translate\n" + 
    "1 -1 scale\n";
  add_intercepts(ctx, this);
};

// look for differences between the current state and the settings to see 
// what has changed. Apply the changes to the eps file.
EpsContext.prototype.detect = function() {
  var state = this.current_state;
  var ctx = this.ctx;
  if (ctx.lineWidth != state.lineWidth) {
    state.lineWidth = ctx.lineWidth;
    this.eps_text += this.indent + state.lineWidth + " setlinewidth\n";
  }
  var cap = parse_line_cap(ctx.lineCap);
  if (cap != state.lineCap) {
    state.lineCap = cap;
    this.eps_text += this.indent + state.lineCap + " setlinecap\n";
  }
  var join = parse_line_join(ctx.lineJoin);
  if (join != state.lineJoin) {
    state.lineJoin = join;
    this.eps_text += this.indent + state.lineJoin + " setlinejoin\n";
  }
  var miterLimit = parseInt(ctx.miterLimit);
  if (miterLimit != state.miterLimit) {
    state.miterLimit = miterLimit;
    this.eps_text += this.indent + state.miterLimit + " setmiterlimit\n";
  }
  var strokeStyle = parse_colour(ctx.strokeStyle);
  if (!colour_equals(strokeStyle, state.strokeStyle)) {
    state.strokeStyle = strokeStyle;
    this.activateStyle(false);
  }
  var fillStyle = parse_colour(ctx.fillStyle);
  if (!colour_equals(fillStyle, state.fillStyle)) {
    state.fillStyle = fillStyle;
    this.activateStyle(true);
  }
  var textAlign = parse_text_align(ctx.textAlign);
  if (textAlign != state.textAlign) {
    state.textAlign = textAlign;
  }
  var textBaseline = parse_text_baseline(ctx.textBaseline);
  if (textBaseline != state.textBaseline) {
    state.textBaseline = textBaseline;
  }
  var font = this.lookup_font(ctx.font);
  if (font !== undefined && font != state.font) {
    state.font = font;
    this.eps_text += this.indent + "/" + font.name + " findfont " +  
      font.size + " scalefont setfont\n";
  }
};

EpsContext.prototype.activateStyle = function(useFillStyle) {
  var state = this.current_state;
  var style = (useFillStyle ? state.fillStyle : state.strokeStyle);
  if (!colour_equals(state.activeStyle, style)) {
    this.eps_text += this.indent + (style.red / 255) + " " + 
      (style.green / 255) + " " + (style.blue / 255) + " setrgbcolor\n";
    state.activeStyle = style;
  }
};


// saves the current state on the stack
EpsContext.prototype.save = function() {
  this.detect();
  // gsave
  this.eps_text += this.indent + "gsave\n";
  this.stack.push(new EpsState(this.current_state));
  this.indent += "  ";
};

// restores the last saved state
EpsContext.prototype.restore = function() {
  if (this.stack.length == 0) throw new Error("Call to restore not matched with call to save.");
  this.detect();
  this.current_state = this.stack.pop();
  this.indent = Array(this.stack.length + 1).join("  ");
  // grestore
  this.eps_text += this.indent + "grestore\n";
};

// start a path
EpsContext.prototype.beginPath = function() {
  this.detect();
  // newpath
  this.eps_text += this.indent + "newpath\n";
};

// join the current position to the path start
EpsContext.prototype.closePath = function() {
  this.detect();
  // closepath
  this.eps_text += this.indent + "closepath\n";
};

// move the current position
EpsContext.prototype.moveTo = function(x, y) {
  this.detect();
  // moveto
  this.eps_text += this.indent + x + " " + y + " moveto\n";
};

// join the current position to a new position and update the current position
EpsContext.prototype.lineTo = function(x, y) {
  this.detect();
  // lineto
  this.eps_text += this.indent + x + " " + y + " lineto\n";
};

// add a rectangle to the path
EpsContext.prototype.rect = function(x, y, width, height) {
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.closePath();
};

// add an arc to the path
EpsContext.prototype.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.detect();
  if (anticlockwise) {
    // command "X Y RADIUS START_ANGLE END_ANGLE arc"
    this.eps_text += this.indent + x + " " + y + " " + radius + " " + rad2deg(startAngle) + " " + rad2deg(endAngle) + " arcn\n";
  } else {
    // command "X Y RADIUS START_ANGLE END_ANGLE arcn"
    this.eps_text += this.indent + x + " " + y + " " + radius + " " + rad2deg(startAngle) + " " + rad2deg(endAngle) + " arc\n";
  }
};

// imagine two lines, one going from the current position to point 1 and
// another going from point 1 to point 2. 
// Now imagine a circle of the given radius which touches the two lines at at 
// two tangental points T01 and T12. Add a line to the path that goes from
// the current position to T01 and add the arc which goes from T01 to T12.
// see http://www.dbp-consulting.com/tutorials/canvas/CanvasArcTo.html
EpsContext.prototype.arcTo = function(cpx1, cpy1, cpx2, cpy2, radius) {
  this.detect();
  // command "X1 Y1 X2 Y2 RADIUS arct"
  this.eps_text += this.indent + cpx1 + " " + cpy1 + " " + cpx2 + " " + cpy2 + " " + radius + " arct\n";
};

EpsContext.prototype.quadraticArcTo = function(cpx, cpy, x, y) {
  /* 
   For the equations below the following variable name prefixes are used: 
     qp0 is the quadratic curve starting point (you must keep this from your 
        last point sent to moveTo(), lineTo(), or bezierCurveTo() ). 
     qp1 is the quadratic curve control point (this is the cpx,cpy you would 
        have sent to quadraticCurveTo() ). 
     qp2 is the quadratic curve ending point (this is the x,y arguments you 
        would have sent to quadraticCurveTo() ). 
   We will convert these points to compute the two needed cubic control points 
    (the starting/ending points are the same for both 
   the quadratic and cubic curves. 
 
   The exact equations for the two cubic control points are: 
     cp0 = qp0 and cp3 = qp2 
     cp1 = qp0 + (qp1 - qp0) * ratio 
     cp2 = cp1 + (qp2 - qp0) * (1 - ratio) 
     where ratio = (sqrt(2) - 1) * 4 / 3 exactly (approx. 0.5522847498307933984022516322796) 
                   if the quadratic is an approximation of an elliptic arc, 
                      and the cubic must approximate the same arc, or 
           ratio = 2.0 / 3.0 for keeping the same quadratic curve. 
 
   In the code below, we must compute both the x and y terms for each point separately. 
 
    cp1x = qp0x + (qp1x - qp0x) * ratio; 
    cp1y = qp0y + (qp1y - qp0y) * ratio; 
    cp2x = cp1x + (qp2x - qp0x) * (1 - ratio); 
    cp2y = cp1y + (qp2y - qp0y) * (1 - ratio); 
 
   We will now  
     a) replace the qp0x and qp0y variables with currentX and currentY 
        (which *you* must store for each moveTo/lineTo/bezierCurveTo) 
     b) replace the qp1x and qp1y variables with cpx and cpy (which we would 
        have passed to quadraticCurveTo) 
     c) replace the qp2x and qp2y variables with x and y. 
   which leaves us with:  
  */  
  var ratio = 2.0 / 3.0; // 0.5522847498307933984022516322796 if the Bezier is 
                        // approximating an elliptic arc with best fitting  
  var cp1x = this.currentX + (cpx - this.currentX) * ratio;  
  var cp1y = this.currentY + (cpy - this.currentY) * ratio;  
  var cp2x = cp1x + (x - this.currentX) * (1 - ratio);  
  var cp2y = cp1y + (y - this.currentY) * (1 - ratio);  
  
  // and now call cubic Bezier curve to function   
  this.bezierCurveTo( cp1x, cp1y, cp2x, cp2y, x, y );
};

// add a bezier curve to the path
EpsContext.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
  this.detect();
  // command "CP1X CP1Y CP2X CP2Y X Y curveto"
  this.eps_text += this.indent + cp1x + " " + cp1y + " " + cp2x + " " + cp2y + " " + x + " " + y + " curveto";
};

// stroke the current path
EpsContext.prototype.stroke = function() {
  this.detect();
  this.activateStyle(false);
  // stroke
  this.eps_text += this.indent + "stroke\n";
};

// fill the current path
EpsContext.prototype.fill = function() {
  this.detect();
  this.activateStyle(true);
  // fill
  this.eps_text += this.indent + "fill\n";
};

// create a clipping region from the current path
EpsContext.prototype.clip = function() {
  this.detect();
  // clip
  this.eps_text += this.indent + "clip\n";
};

// Draws a filled rectangle
EpsContext.prototype.fillRect = function(x, y, width, height) {
  this.detect();
  this.activateStyle(true);
  // rectfill
  this.eps_text += this.indent + x + " " + y + " " + width + " " + height + " rectfill\n";
};

// Draws a rectangular outline
EpsContext.prototype.strokeRect = function(x, y, width, height) {
  this.detect();
  this.activateStyle(false);
  // rectstroke
  this.eps_text += this.indent + x + " " + y + " " + width + " " + height + " rectstroke\n";
};

// Clears the specified area and makes it transparent.
EpsContext.prototype.clearRect = function(x, y, width, height) {
  this.detect();
  // fill a rectangle with white in the cleared region
  // EPS doesn't do transparency so this is as close as it can get
  // command "1 setgray X Y WIDTH HEIGHT rectfill"
  this.eps_text += this.indent + "gsave\n";
  this.eps_text += this.indent + "  1 setgray\n";
  this.eps_text += this.indent + "  " + x + " " + y + " " + width + " " + height + " rectfill\n";
  this.eps_text += this.indent + "grestore\n";
};

// Draws a filled string
EpsContext.prototype.fillText = function(string, x, y) {
  var state = this.current_state;
  this.detect();
  this.activateStyle(true);
  // lookup the font with "/FONT_NAME findfont" (leaves FONT on stack)
  // scale the font with "FONT SIZE scalefont" (leaves FONT on stack
  // set the font with "FONT setfont"
  // move the printing location with "X Y moveto"
  // various measurement commands will be needed to do center alignment etc
  // like "stringwidth"
  // show the text with "(STRING) show"
  string = string.replace(/\\/g, "\\\\");
  string = string.replace(/\(/g, "\\(");
  string = string.replace(/\)/g, "\\)");
  this.save();
  this.translate(x, y);
  this.scale(1, -1);
  this.eps_text += this.indent + "(" + string + ")\n";
  if (state.textBaseline != "alphabetic") {
    this.beginPath();
    this.moveTo(0,0);
    this.eps_text += this.indent + "dup true charpath flattenpath pathbbox %bounding box\n";
    this.eps_text += this.indent + "/ascent exch def pop /decent exch def pop\n";
    if (state.textBaseline == "top") {
      this.eps_text += this.indent + "0 ascent neg translate %vertical align top\n";
    } else if (state.textBaseline == "middle") {
      this.eps_text += this.indent + "0 ascent decent sub 2 div decent sub neg translate %vertical align middle\n";
    } else if (state.textBaseline == "bottom") {
      this.eps_text += this.indent + "0 decent neg translate %vertical align bottom\n";
    }
  }
  if (state.textAlign == "right") {
    this.eps_text += this.indent + "dup stringwidth pop neg 0 translate %right align\n"  
  } else if (state.textAlign == "center") {
    this.eps_text += this.indent + "dup stringwidth pop 2 div neg 0 translate %center align\n"  
  }
  this.moveTo(0,0);
  this.eps_text += this.indent + "show\n";
  this.restore();
};

// move the canvas origin
EpsContext.prototype.translate = function(dx, dy) {
  this.detect();
  // command "DELTA_X DELTA_Y translate"
  this.eps_text += this.indent + dx + " " + dy + " translate\n";
};

// rotate around the canvas origin
EpsContext.prototype.rotate = function(angle) {
  this.detect();
  // command "DEGREES rotate" (note need to convert angle from radians to degrees)
  this.eps_text += this.indent + rad2deg(angle) + " rotate\n";
};

// scale 
EpsContext.prototype.scale = function(scale_x, scale_y) {
  this.detect();
  // command "SCALE_X SCALE_Y scale
  this.eps_text += this.indent + scale_x + " " + scale_y + " scale\n";
};

// multiplies the current transform matrix by the matrix described by:
// m11    m21   dx
// m12    m22   dy
// 0      0     1
EpsContext.prototype.transform = function(m11, m12, m21, m22, dx, dy) {
  this.detect();
  // command "[M11 M12 M21 M22 DX DY] concat"
  this.eps_text += this.indent + "[" + m11 + " " + m12 + " " + m21 + " " + m22 + " " + dx + " " + dy + "] concat\n";
};

// reset transform matrix to the identity matrix then call transform
EpsContext.prototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
  // command:
  // "[1 0 0 1 0 0] defaultmatrix setmatrix 0 height translate 1 -1 scale "
  // "[M11 M12 M21 M22 DX DY] concat"
  this.eps_text += this.indent + "[1 0 0 1 0 0] defaultmatrix setmatrix\n";
  this.eps_text += this.indent + "0 " + this.height + " translate\n";
  this.eps_text += this.indent + "1 -1 scale\n";
  this.transform(m11, m12, m21, m22, dx, dy);
};

EpsContext.prototype.register_font = function(font_str, eps_font, size) {
  font_str = font_str.replace(/\s+/g, ""); // remove spaces
  font_str = font_str.toLowerCase(); // lower case
  this.font_lookup[font_str] = {'name': eps_font, 'size': size};
};

EpsContext.prototype.lookup_font = function(font_str) {
  font_str = font_str.replace(/\s+/g, ""); // remove spaces
  font_str = font_str.toLowerCase(); // lower case
  return this.font_lookup[font_str];
};

// return the EPS text
EpsContext.prototype.eps = function() {
  return this.eps_text + this.indent + "showpage\n";
};

    </script>
    <script type="text/javascript">
//======================================================================
// start Alphabet object
//======================================================================
var Alphabet = function (alphabet, bg) {
  "use strict";
  var is_letter, is_prob, pos, letter, parts, i, freq;
  //variable prototype
  this.freqs = new Array();
  this.alphabet = new Array();
  this.letter_count = 0;
  //construct
  is_letter = /^\w$/;
  is_prob = /^((1(\.0+)?)|(0(\.\d+)?))$/;
  for (pos = 0; pos < alphabet.length; pos++) {
    letter = alphabet.charAt(pos);
    if (is_letter.test(letter)) {
      this.alphabet[this.letter_count] = letter.toUpperCase();
      this.freqs[this.letter_count] = -1;
      this.letter_count++;
    }
  }
  if (typeof bg !== "undefined") {
    parts = bg.split(/\s+/);
    for (i = 0, pos = 0; (i + 1) < parts.length; i += 2) {
      letter = parts[i];
      freq = parts[i+1];
      if (is_letter.test(letter) && is_prob.test(freq)) {
        letter = letter.toUpperCase();          //find the letter it matches
        for (;pos < this.letter_count; pos++) {
          if (this.alphabet[pos] == letter) {
            break;
          }
        }
        if (pos >= this.letter_count) {
          throw new Error("NOT_IN_ALPHABET");
        }
        this.freqs[pos] = (+freq);
      }
    }
  } else {
    //assume uniform background
    freq = 1.0 / this.letter_count;
    for (pos = 0; pos < this.letter_count; pos++) {
      this.freqs[pos] = freq;
    }
  }
};


Alphabet.prototype.get_ic = function() {
  "use strict";
  if (this.is_nucleotide()) {
    return 2;
  } else {
    return Math.log(20) / Math.LN2;
  }
};

Alphabet.prototype.get_size = function() {
  "use strict";
  return this.letter_count;
};

Alphabet.prototype.get_letter = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.letter_count) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  return this.alphabet[alph_index];
};

Alphabet.prototype.get_bg_freq = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.letter_count) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (this.freqs[alph_index] == -1) {
    throw new Error("BG_FREQ_NOT_SET");
  }
  return this.freqs[alph_index];
};

Alphabet.prototype.get_colour = function(alph_index) {
  "use strict";
  var red, blue, orange, green, yellow, purple, magenta, pink, turquoise;
  red = "rgb(204,0,0)";
  blue = "rgb(0,0,204)";
  orange = "rgb(255,179,0)";
  green = "rgb(0,128,0)";
  yellow = "rgb(255,255,0)";
  purple = "rgb(204,0,204)";
  magenta = "rgb(255,0,255)";
  pink = "rgb(255,204,204)";
  turquoise = "rgb(51,230,204)";
  if (alph_index < 0 || alph_index >= this.letter_count) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (this.is_nucleotide()) {
    switch (this.alphabet[alph_index]) {
      case "A":
        return red;
      case "C":
        return blue;
      case "G":
        return orange;
      case "T":
        return green;
      default:
        throw new Error("Invalid nucleotide letter");
    }
  } else {
    switch (this.alphabet[alph_index]) {
      case "A":
      case "C":
      case "F":
      case "I":
      case "L":
      case "V":
      case "W":
      case "M":
        return blue;
      case "N":
      case "Q":
      case "S":
      case "T":
        return green;
      case "D":
      case "E":
        return magenta;
      case "K":
      case "R":
        return red;
      case "H":
        return pink;
      case "G":
        return orange;
      case "P":
        return yellow;
      case "Y":
        return turquoise;
      default:
        throw new Error("Invalid protein letter");
    }
  }
  return "black";
};

Alphabet.prototype.is_ambig = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.letter_count) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (this.is_nucleotide()) {
    return ("ACGT".indexOf(this.alphabet[alph_index]) == -1);
  } else {
    return ("ACDEFGHIKLMNPQRSTVWY".indexOf(this.alphabet[alph_index]) == -1);
  }
};

Alphabet.prototype.get_index = function(letter) {
  "use strict";
  var i;
  for (i = 0; i < this.letter_count; i++) {
    if (this.alphabet[i] == letter.toUpperCase()) {
      return i;
    }
  }
  throw new Error("UNKNOWN_LETTER");
};

Alphabet.prototype.is_nucleotide = function() {
  "use strict";
  //TODO basic method, make better
  if (this.letter_count < 20) {
    return true;
  }
  return false;
};

Alphabet.prototype.toString = function() {
  "use strict";
  return (this.is_nucleotide() ? "Nucleotide" : "Protein") + 
    " Alphabet " + (this.alphabet.join(""));
};

//======================================================================
// end Alphabet object
//======================================================================

//======================================================================
// start Symbol object
//======================================================================
var Symbol = function(alph_index, scale, alphabet) {
  "use strict";
  //variable prototype
  this.symbol = alphabet.get_letter(alph_index);
  this.scale = scale;
  this.colour = alphabet.get_colour(alph_index);
};

Symbol.prototype.get_symbol = function() {
  "use strict";
  return this.symbol;
};

Symbol.prototype.get_scale = function() {
  "use strict";
  return this.scale;
};

Symbol.prototype.get_colour = function() {
  "use strict";
  return this.colour;
};

Symbol.prototype.toString = function() {
  "use strict";
  return this.symbol + " " + (Math.round(this.scale*1000)/10) + "%";
};

function compare_symbol(sym1, sym2) {
  "use strict";
  if (sym1.get_scale() < sym2.get_scale()) {
    return -1;
  } else if (sym1.get_scale() > sym2.get_scale()) {
    return 1;
  } else {
    return 0;
  }
}
//======================================================================
// end Symbol object
//======================================================================

//======================================================================
// start Pspm object
//======================================================================
var Pspm = function(matrix, name, ltrim, rtrim, nsites, evalue) {
  "use strict";
  var row, col, data, row_sum, delta, evalue_re;
  if (typeof name !== "string") {
    name = "";
  }
  this.name = name;
  //construct
  if (matrix instanceof Pspm) {
    // copy constructor
    this.alph_length = matrix.alph_length;
    this.motif_length = matrix.motif_length;
    this.name = matrix.name;
    this.nsites = matrix.nsites;
    this.evalue = matrix.evalue;
    this.ltrim = matrix.ltrim;
    this.rtrim = matrix.rtrim;
    this.pspm = [];
    for (row = 0; row < matrix.motif_length; row++) {
      this.pspm[row] = [];
      for (col = 0; col < matrix.alph_length; col++) {
        this.pspm[row][col] = matrix.pspm[row][col];
      }
    }
  } else {
    // check parameters
    if (typeof ltrim === "undefined") {
      ltrim = 0;
    } else if (typeof ltrim !== "number" || ltrim % 1 !== 0 || ltrim < 0) {
      throw new Error("ltrim must be a non-negative integer, got: " + ltrim);
    }
    if (typeof rtrim === "undefined") {
      rtrim = 0;
    } else if (typeof rtrim !== "number" || rtrim % 1 !== 0 || rtrim < 0) {
      throw new Error("rtrim must be a non-negative integer, got: " + rtrim);
    }
    if (typeof nsites !== "undefined") {
      if (typeof nsites !== "number" || nsites <= 0) {
        throw new Error("nsites must be a positive number, got: " + nsites);
      }
    }
    if (typeof evalue !== "undefined") {
      if (typeof evalue === "number") {
        if (evalue < 0) {
          throw new Error("evalue must be a non-negative number, got: " + evalue);
        }
      } else if (typeof evalue === "string") {
        evalue_re = /^((?:[+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|inf)$/;
        if (!evalue_re.test(evalue)) {
          throw new Error("evalue must be a non-negative number, got: " + evalue);
        }
      } else {
        throw new Error("evalue must be a non-negative number, got: " + evalue);
      }
    }
    // set properties
    this.name = name;
    this.nsites = nsites;
    this.evalue = evalue;
    this.ltrim = ltrim;
    this.rtrim = rtrim;
    if (typeof matrix === "string") {
      // string constructor
      data = parse_pspm_string(matrix);
      this.alph_length = data["alph_length"];
      this.motif_length = data["motif_length"];
      this.pspm = data["pspm"];
      if (typeof this.evalue === "undefined") {
        if (typeof data["evalue"] !== "undefined") {
          this.evalue = data["evalue"];
        } else {
          this.evalue = 0;
        }
      }
      if (typeof this.nsites === "undefined") {
        if (typeof data["nsites"] === "number") {
          this.nsites = data["nsites"];
        } else {
          this.nsites = 20;
        }
      }
    } else {
      // assume pspm is a nested array
      this.motif_length = matrix.length;
      this.alph_length = (matrix.length > 0 ? matrix[0].length : 0);
      if (typeof this.nsites === "undefined") {
        this.nsites = 20;
      }
      if (typeof this.evalue === "undefined") {
        this.evalue = 0;
      }
      this.pspm = [];
      // copy pspm and check
      for (row = 0; row < this.motif_length; row++) {
        if (this.alph_length != matrix[row].length) {
          throw new Error("COLUMN_MISMATCH");
        }
        this.pspm[row] = [];
        row_sum = 0;
        for (col = 0; col < this.alph_length; col++) {
          this.pspm[row][col] = matrix[row][col];
          row_sum += this.pspm[row][col];
        }
        delta = 0.1;
        if (isNaN(row_sum) || (row_sum > 1 && (row_sum - 1) > delta) || 
            (row_sum < 1 && (1 - row_sum) > delta)) {
          throw new Error("INVALID_SUM");
        }
      }
    }
  }
};

Pspm.prototype.copy = function() {
  "use strict";
  return new Pspm(this);
};

Pspm.prototype.reverse_complement = function(alphabet) {
  "use strict";
  var x, y, temp, a_index, c_index, g_index, t_index, i, row, temp_trim;
  if (this.alph_length != alphabet.get_size()) {
    throw new Error("ALPHABET_MISMATCH");
  }
  if (!alphabet.is_nucleotide()) {
    throw new Error("NO_PROTEIN_RC");
  }
  //reverse
  x = 0;
  y = this.motif_length-1;
  while (x < y) {
    temp = this.pspm[x];
    this.pspm[x] = this.pspm[y];
    this.pspm[y] = temp;
    x++;
    y--;
  }
  //complement
  a_index = alphabet.get_index("A");
  c_index = alphabet.get_index("C");
  g_index = alphabet.get_index("G");
  t_index = alphabet.get_index("T");
  for (i = 0; i < this.motif_length; i++) {
    row = this.pspm[i];
    //swap A and T
    temp = row[a_index];
    row[a_index] = row[t_index];
    row[t_index] = temp;
    //swap C and G
    temp = row[c_index];
    row[c_index] = row[g_index];
    row[g_index] = temp;
  }
  //swap triming
  temp_trim = this.ltrim;
  this.ltrim = this.rtrim;
  this.rtrim = temp_trim;
  //note that ambigs are ignored because they don't effect motifs
  return this; //allow function chaining...
};

Pspm.prototype.get_stack = function(position, alphabet) {
  "use strict";
  var row, stack_ic, alphabet_ic, stack, i, sym;
  if (this.alph_length != alphabet.get_size()) {
    throw new Error("ALPHABET_MISMATCH");
  }
  row = this.pspm[position];
  stack_ic = this.get_stack_ic(position, alphabet);
  alphabet_ic = alphabet.get_ic();
  stack = [];
  for (i = 0; i < this.alph_length; i++) {
    if (alphabet.is_ambig(i)) {
      continue;
    }
    sym = new Symbol(i, row[i]*stack_ic/alphabet_ic, alphabet);
    if (sym.get_scale() <= 0) {
      continue;
    }
    stack.push(sym);
  }
  stack.sort(compare_symbol);
  return stack;
};

Pspm.prototype.get_stack_ic = function(position, alphabet) {
  "use strict";
  var row, H, i;
  if (this.alph_length != alphabet.get_size()) {
    throw new Error("ALPHABET_MISMATCH");
  }
  row = this.pspm[position];
  H = 0;
  for (i = 0; i < this.alph_length; i++) {
    if (alphabet.is_ambig(i)) {
      continue;
    }
    if (row[i] === 0) {
      continue;
    }
    H -= (row[i] * (Math.log(row[i]) / Math.LN2));
  }
  return alphabet.get_ic() - H;
};

Pspm.prototype.get_error = function(alphabet) {
  "use strict";
  var asize;
  if (this.nsites === 0) {
    return 0;
  }
  if (alphabet.is_nucleotide()) {
    asize = 4;
  } else {
    asize = 20;
  }
  return (asize-1) / (2 * Math.log(2)*this.nsites);
};

Pspm.prototype.get_motif_length = function() {
  "use strict";
  return this.motif_length;
};

Pspm.prototype.get_alph_length = function() {
  "use strict";
  return this.alph_length;
};

Pspm.prototype.get_left_trim = function() {
  "use strict";
  return this.ltrim;
};

Pspm.prototype.get_right_trim = function() {
  "use strict";
  return this.rtrim;
};

Pspm.prototype.as_pspm = function() {
  "use strict";
  var out, row, col;
  out = "letter-probability matrix: alength= " + this.alph_length + 
      " w= " + this.motif_length + " nsites= " + this.nsites + 
      " E= " + (typeof this.evalue === "number" ? 
          this.evalue.toExponential() : this.evalue) + "\n";
  for (row = 0; row < this.motif_length; row++) {
    for (col = 0; col < this.alph_length; col++) {
      if (col !== 0) {
        out += " ";
      }
      out += this.pspm[row][col].toFixed(6);
    }
    out += "\n";
  }
  return out;
};

Pspm.prototype.as_pssm = function(alphabet, pseudo) {
  "use strict";
  var out, log2, total, row, col, p, bg, p2, score;
  if (typeof pseudo === "undefined") {
    pseudo = 0.1;
  } else if (typeof pseudo !== "number") {
    throw new Error("Expected number for pseudocount");
  }
  out = "log-odds matrix: alength= " + this.alph_length + 
      " w= " + this.motif_length + 
      " E= " + (typeof this.evalue == "number" ? 
          this.evalue.toExponential() : this.evalue) + "\n";
  log2 = Math.log(2);
  total = this.nsites + pseudo;
  for (row = 0; row < this.motif_length; row++) {
    for (col = 0; col < this.alph_length; col++) {
      if (col !== 0) {
        out += " ";
      }
      p = this.pspm[row][col];
      // to avoid log of zero we add a pseudo count
      bg = alphabet.get_bg_freq(col);
      p2 = (p * this.nsites + bg * pseudo) / total;
      // now calculate the score
      score = -10000;
      if (p2 > 0) {
        score = Math.round((Math.log(p2 / bg) / log2) * 100);
      }
      out += score;
    }
    out += "\n";
  }
  return out;
};

Pspm.prototype.toString = function() {
  "use strict";
  var str, i, row;
  str = "";
  for (i = 0; i < this.pspm.length; i++) {
    row = this.pspm[i];
    str += row.join("\t") + "\n";
  }
  return str;
};

function parse_pspm_properties(str) {
  "use strict";
  var parts, i, eqpos, before, after, properties, prop, num, num_re;
  num_re = /^((?:[+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|inf)$/;
  parts = trim(str).split(/\s+/);
  // split up words containing =
  for (i = 0; i < parts.length;) {
    eqpos = parts[i].indexOf("=");
    if (eqpos != -1) {
      before = parts[i].substr(0, eqpos);
      after = parts[i].substr(eqpos+1);
      if (before.length > 0 && after.length > 0) {
        parts.splice(i, 1, before, "=", after);
        i += 3;
      } else if (before.length > 0) {
        parts.splice(i, 1, before, "=");
        i += 2;
      } else if (after.length > 0) {
        parts.splice(i, 1, "=", after);
        i += 2;
      } else {
        parts.splice(i, 1, "=");
        i++;
      }
    } else {
      i++;
    }
  }
  properties = {};
  for (i = 0; i < parts.length; i += 3) {
    if (parts.length - i < 3) {
      throw new Error("Expected PSPM property was incomplete. "+
          "Remaing parts are: " + parts.slice(i).join(" "));
    }
    if (parts[i+1] !== "=") {
      throw new Error("Expected '=' in PSPM property between key and " +
          "value but got " + parts[i+1]); 
    }
    prop = parts[i].toLowerCase();
    num = parts[i+2];
    if (!num_re.test(num)) {
      throw new Error("Expected numeric value for PSPM property '" + 
          prop + "' but got '" + num + "'");
    }
    properties[prop] = num;
  }
  return properties;
}

function parse_pspm_string(pspm_string) {
  "use strict";
  var header_re, lines, first_line, line_num, col_num, alph_length, 
      motif_length, nsites, evalue, pspm, i, line, match, props, parts,
      j, prob;
  header_re = /^letter-probability\s+matrix:(.*)$/i;
  lines = pspm_string.split(/\n/);
  first_line = true;
  line_num = 0;
  col_num = 0;
  alph_length;
  motif_length;
  nsites;
  evalue;
  pspm = [];
  for (i = 0; i < lines.length; i++) {
    line = trim(lines[i]);
    if (line.length === 0) { 
      continue;
    }
    // check the first line for a header though allow matrices without it
    if (first_line) {
      first_line = false;
      match = header_re.exec(line);
      if (match !== null) {
        props = parse_pspm_properties(match[1]);
        if (props.hasOwnProperty("alength")) {
          alph_length = parseFloat(props["alength"]);
          if (alph_length != 4 && alph_length != 20) {
            throw new Error("PSPM property alength should be 4 or 20" +
                " but got " + alph_length);
          }
        }
        if (props.hasOwnProperty("w")) {
          motif_length = parseFloat(props["w"]);
          if (motif_length % 1 !== 0 || motif_length < 1) {
            throw new Error("PSPM property w should be an integer larger " +
                "than zero but got " + motif_length);
          }
        }
        if (props.hasOwnProperty("nsites")) {
          nsites = parseFloat(props["nsites"]);
          if (nsites <= 0) {
            throw new Error("PSPM property nsites should be larger than " +
                "zero but got " + nsites);
          }
        }
        if (props.hasOwnProperty("e")) {
          evalue = props["e"];
          if (evalue < 0) {
            throw new Error("PSPM property evalue should be " +
                "non-negative but got " + evalue);
          }
        }
        continue;
      }
    }
    pspm[line_num] = [];
    col_num = 0;
    parts = line.split(/\s+/);
    for (j = 0; j < parts.length; j++) {
      prob = parseFloat(parts[j]);
      if (prob != parts[j] || prob < 0 || prob > 1) {
        throw new Error("Expected probability but got '" + parts[j] + "'"); 
      }
      pspm[line_num][col_num] = prob;
      col_num++;
    }
    line_num++;
  }
  if (typeof motif_length === "number") {
    if (pspm.length != motif_length) {
      throw new Error("Expected PSPM to have a motif length of " + 
          motif_length + " but it was actually " + pspm.length);
    }
  } else {
    motif_length = pspm.length;
  }
  if (typeof alph_length !== "number") {
    alph_length = pspm[0].length;
    if (alph_length != 4 && alph_length != 20) {
      throw new Error("Expected length of first row in the PSPM to be " +
          "either 4 or 20 but got " + alph_length);
    }
  }
  for (i = 0; i < pspm.length; i++) {
    if (pspm[i].length != alph_length) {
      throw new Error("Expected PSPM row " + i + " to have a length of " + 
          alph_length + " but the length was " + pspm[i].length);
    }
  }
  return {"pspm": pspm, "motif_length": motif_length, 
    "alph_length": alph_length, "nsites": nsites, "evalue": evalue};
}
//======================================================================
// end Pspm object
//======================================================================

//======================================================================
// start Logo object
//======================================================================

var Logo = function(alphabet, fine_text) {
  "use strict";
  this.alphabet = alphabet;
  this.fine_text = fine_text;
  this.pspm_list = [];
  this.pspm_column = [];
  this.rows = 0;
  this.columns = 0;
};

Logo.prototype.add_pspm = function(pspm, column) {
  "use strict";
  var col;
  if (typeof column === "undefined") {
    column = 0;
  } else if (column < 0) {
    throw new Error("Column index out of bounds.");
  }
  this.pspm_list[this.rows] = pspm;
  this.pspm_column[this.rows] = column;
  this.rows++;
  col = column + pspm.get_motif_length();
  if (col > this.columns) {
    this.columns = col;
  }
};

Logo.prototype.get_columns = function() {
  "use strict";
  return this.columns;
};

Logo.prototype.get_rows = function() {
  "use strict";
  return this.rows;
};

Logo.prototype.get_pspm = function(row_index) {
  "use strict";
  if (row_index < 0 || row_index >= this.rows) {
    throw new Error("INDEX_OUT_OF_BOUNDS");
  }
  return this.pspm_list[row_index];
};

Logo.prototype.get_offset = function(row_index) {
  "use strict";
  if (row_index < 0 || row_index >= this.rows) {
    throw new Error("INDEX_OUT_OF_BOUNDS");
  }
  return this.pspm_column[row_index];
};

//======================================================================
// end Logo object
//======================================================================

//======================================================================
// start RasterizedAlphabet
//======================================================================

// Rasterize Alphabet
// 1) Measure width of text at default font for all symbols in alphabet
// 2) sort in width ascending
// 3) Drop the top and bottom 10% (designed to ignore outliers like 'W' and 'I')
// 4) Calculate the average as the maximum scaling factor (designed to stop I becoming a rectangular blob).
// 5) Assume scale of zero would result in width of zero, interpolate scale required to make perfect width font
// 6) Draw text onto temp canvas at calculated scale
// 7) Find bounds of drawn text
// 8) Paint on to another canvas at the desired height (but only scaling width to fit if larger).
var RasterizedAlphabet = function(alphabet, font, target_width) {
  "use strict";
  var default_size, safety_pad, canvas, ctx, middle, baseline, widths, count,
      letters, i, letter, size, tenpercent, avg_width, scale, 
      target_height, raster;
  //variable prototypes
  this.lookup = []; //a map of letter to index
  this.rasters = []; //a list of rasters
  this.dimensions = []; //a list of dimensions

  //construct
  default_size = 60; // size of square to assume as the default width
  safety_pad = 20; // pixels to pad around so we don't miss the edges
  // create a canvas to do our rasterizing on
  canvas = document.createElement("canvas");
  // assume the default font would fit in a canvas of 100 by 100
  canvas.width = default_size + 2 * safety_pad;
  canvas.height = default_size + 2 * safety_pad;
  // check for canvas support before attempting anything
  if (!canvas.getContext) {
    throw new Error("NO_CANVAS_SUPPORT");
  }
  ctx = canvas.getContext('2d');
  // check for html5 text drawing support
  if (!supports_text(ctx)) {
    throw new Error("NO_CANVAS_TEXT_SUPPORT");
  }
  // calculate the middle
  middle = Math.round(canvas.width / 2);
  // calculate the baseline
  baseline = Math.round(canvas.height - safety_pad);
  // list of widths
  widths = [];
  count = 0;
  letters = [];
  //now measure each letter in the alphabet
  for (i = 0; i < alphabet.get_size(); ++i) {
    if (alphabet.is_ambig(i)) {
      continue; //skip ambigs as they're never rendered
    }
    letter = alphabet.get_letter(i);
    letters.push(letter);
    this.lookup[letter] = count;
    //clear the canvas
    canvas.width = canvas.width;
    // get the context and prepare to draw our width test
    ctx = canvas.getContext('2d');
    ctx.font = font;
    ctx.fillStyle = alphabet.get_colour(i);
    ctx.textAlign = "center";
    ctx.translate(middle, baseline);
    // draw the test text
    ctx.fillText(letter, 0, 0);
    //measure
    size = canvas_bounds(ctx, canvas.width, canvas.height);
    if (size.width === 0) {
      throw new Error("INVISIBLE_LETTER"); //maybe the fill was white on white?
    }
    widths.push(size.width);
    this.dimensions[count] = size;
    count++;
  }
  //sort the widths
  widths.sort(function(a,b) {return a - b;});
  //drop 10% of the items off each end
  tenpercent = Math.floor(widths.length / 10);
  for (i = 0; i < tenpercent; ++i) {
    widths.pop();
    widths.shift();
  }
  //calculate average width
  avg_width = 0;
  for (i = 0; i < widths.length; ++i) {
    avg_width += widths[i];
  }
  avg_width /= widths.length;
  // calculate scales
  for (i = 0; i < this.dimensions.length; ++i) {
    size = this.dimensions[i];
    // calculate scale
    scale = target_width / Math.max(avg_width, size.width);
    // estimate scaled height
    target_height = size.height * scale;
    // create an approprately sized canvas
    raster = document.createElement("canvas");
    raster.width = target_width; // if it goes over the edge too bad...
    raster.height = target_height + safety_pad * 2;
    // calculate the middle
    middle = Math.round(raster.width / 2);
    // calculate the baseline
    baseline = Math.round(raster.height - safety_pad);
    // get the context and prepare to draw the rasterized text
    ctx = raster.getContext('2d');
    ctx.font = font;
    ctx.fillStyle = alphabet.get_colour(i);
    ctx.textAlign = "center";
    ctx.translate(middle, baseline);
    ctx.save();
    ctx.scale(scale, scale);
    // draw the rasterized text
    ctx.fillText(letters[i], 0, 0);
    ctx.restore();
    this.rasters[i] = raster;
    this.dimensions[i] = canvas_bounds(ctx, raster.width, raster.height);
  }
};

function canvas_bounds(ctx, cwidth, cheight) {
  "use strict";
  var data, r, c, top_line, bottom_line, left_line, right_line, 
      txt_width, txt_height;
  data = ctx.getImageData(0, 0, cwidth, cheight).data;
  r = 0; c = 0; // r: row, c: column
  top_line = -1; bottom_line = -1; left_line = -1; right_line = -1;
  txt_width = 0; txt_height = 0;
  // Find the top-most line with a non-white pixel
  for (r = 0; r < cheight; r++) {
    for (c = 0; c < cwidth; c++) {
      if (data[r * cwidth * 4 + c * 4 + 3]) {
        top_line = r;
        break;
      }
    }
    if (top_line != -1) {
      break;
    }
  }
  
  //find the last line with a non-white pixel
  if (top_line != -1) {
    for (r = cheight-1; r >= top_line; r--) {
      for(c = 0; c < cwidth; c++) {
        if(data[r * cwidth * 4 + c * 4 + 3]) {
          bottom_line = r;
          break;
        }
      }
      if (bottom_line != -1) {
        break;
      }
    }
    txt_height = bottom_line - top_line + 1;
  }

  // Find the left-most line with a non-white pixel
  for (c = 0; c < cwidth; c++) {
    for (r = 0; r < cheight; r++) {
      if (data[r * cwidth * 4 + c * 4 + 3]) {
        left_line = c;
        break;
      }
    }
    if (left_line != -1) {
      break;
    }
  }

  //find the right most line with a non-white pixel
  if (left_line != -1) {
    for (c = cwidth-1; c >= left_line; c--) {
      for(r = 0; r < cheight; r++) {
        if(data[r * cwidth * 4 + c * 4 + 3]) {
          right_line = c;
          break;
        }
      }
      if (right_line != -1) {
        break;
      }
    }
    txt_width = right_line - left_line + 1;
  }

  //return the bounds
  return {bound_top: top_line, bound_bottom: bottom_line, 
    bound_left: left_line, bound_right: right_line, width: txt_width, 
    height: txt_height};
}

RasterizedAlphabet.prototype.draw = function(ctx, letter, dx, dy, dWidth, dHeight) {
  "use strict";
  var index, raster, size;
  index = this.lookup[letter];
  raster = this.rasters[index];
  size = this.dimensions[index];
  ctx.drawImage(raster, 0, size.bound_top -1, raster.width, size.height+1, dx, dy, dWidth, dHeight);
};

//======================================================================
// end RasterizedAlphabet
//======================================================================

//======================================================================
// start LogoMetrics object
//======================================================================

var LogoMetrics = function(ctx, logo_columns, logo_rows, allow_space_for_names) {
  "use strict";
  var i, row_height;
  if (typeof allow_space_for_names === "undefined") {
    allow_space_for_names = false;
  }
  //variable prototypes
  this.pad_top = 5;
  this.pad_left = 10;
  this.pad_right = 5;
  this.pad_bottom = 0;
  this.pad_middle = 20;
  this.name_height = 14;
  this.name_font = "bold " + this.name_height + "px Times, sans-serif";
  this.name_spacer = 0;
  this.y_label = "bits";
  this.y_label_height = 12;
  this.y_label_font = "bold " + this.y_label_height + "px Helvetica, sans-serif";
  this.y_label_spacer = 3;
  this.y_num_height = 12;
  this.y_num_width = 0;
  this.y_num_font = "bold " + this.y_num_height + "px Helvetica, sans-serif";
  this.y_tic_width = 5;
  this.stack_pad_left = 0;
  this.stack_font = "bold 25px Helvetica, sans-serif";
  this.stack_height = 90;
  this.stack_width = 26;
  this.stacks_pad_right = 5;
  this.x_num_above = 2;
  this.x_num_height = 12;
  this.x_num_width = 0;
  this.x_num_font = "bold " + this.x_num_height + "px Helvetica, sans-serif";
  this.fine_txt_height = 6;
  this.fine_txt_above = 2;
  this.fine_txt_font = "normal " + this.fine_txt_height + "px Helvetica, sans-serif";
  this.letter_metrics = new Array();
  this.summed_width = 0;
  this.summed_height = 0;
  //calculate the width of the y axis numbers
  ctx.font = this.y_num_font;
  for (i = 0; i <= 2; i++) {
    this.y_num_width = Math.max(this.y_num_width, ctx.measureText("" + i).width);
  }
  //calculate the width of the x axis numbers (but they are rotated so it becomes height)
  ctx.font = this.x_num_font;
  for (i = 1; i <= logo_columns; i++) {
    this.x_num_width = Math.max(this.x_num_width, ctx.measureText("" + i).width);
  }
  
  //calculate how much vertical space we want to draw this
  //first we add the padding at the top and bottom since that's always there
  this.summed_height += this.pad_top + this.pad_bottom;
  //all except the last row have the same amount of space allocated to them
  if (logo_rows > 1) {
    row_height = this.stack_height + this.pad_middle;
    if (allow_space_for_names) {
      row_height += this.name_height;
      //the label is allowed to overlap into the spacer
      row_height += Math.max(this.y_num_height/2, this.name_spacer); 
      //the label is allowed to overlap the space used by the other label
      row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
    } else {
      row_height += this.y_num_height/2; 
      //the label is allowed to overlap the space used by the other label
      row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
    }
    this.summed_height += row_height * (logo_rows - 1);
  }
  //the last row has the name and fine text below it but no padding
  this.summed_height += this.stack_height + this.y_num_height/2;
  if (allow_space_for_names) {
    this.summed_height += this.fine_txt_height + this.fine_txt_above + this.name_height;
    this.summed_height += Math.max(this.y_num_height/2, 
        this.x_num_height + this.x_num_above + this.name_spacer);
  } else {
    this.summed_height += Math.max(this.y_num_height/2, 
        this.x_num_height + this.x_num_above + this.fine_txt_height + this.fine_txt_above);
  }

  //calculate how much horizontal space we want to draw this
  //first add the padding at the left and right since that's always there
  this.summed_width += this.pad_left + this.pad_right;
  //add on the space for the y-axis label
  this.summed_width += this.y_label_height + this.y_label_spacer;
  //add on the space for the y-axis
  this.summed_width += this.y_num_width + this.y_tic_width;
  //add on the space for the stacks
  this.summed_width += (this.stack_pad_left + this.stack_width) * logo_columns;
  //add on the padding after the stacks (an offset from the fine text)
  this.summed_width += this.stacks_pad_right;

};

//======================================================================
// end LogoMetrics object
//======================================================================

//found this trick at http://talideon.com/weblog/2005/02/detecting-broken-images-js.cfm
function image_ok(img) {
  "use strict";
  // During the onload event, IE correctly identifies any images that
  // weren't downloaded as not complete. Others should too. Gecko-based
  // browsers act like NS4 in that they report this incorrectly.
  if (!img.complete) {
    return false;
  }
  // However, they do have two very useful properties: naturalWidth and
  // naturalHeight. These give the true size of the image. If it failed
  // to load, either of these should be zero.
  if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) {
    return false;
  }
  // No other way of checking: assume it's ok.
  return true;
}
  
function supports_text(ctx) {
  "use strict";
  if (!ctx.fillText) {
    return false;
  }
  if (!ctx.measureText) {
    return false;
  }
  return true;
}

//draws the scale, returns the width
function draw_scale(ctx, metrics, alphabet_ic) {
  "use strict";
  var tic_height, i;
  tic_height = metrics.stack_height / alphabet_ic;
  ctx.save();
  ctx.lineWidth = 1.5;
  ctx.translate(metrics.y_label_height, metrics.y_num_height/2);
  //draw the axis label
  ctx.save();
  ctx.font = metrics.y_label_font;
  ctx.translate(0, metrics.stack_height/2);
  ctx.save();
  ctx.rotate(-(Math.PI / 2));
  ctx.textAlign = "center";
  ctx.fillText("bits", 0, 0);
  ctx.restore();
  ctx.restore();

  ctx.translate(metrics.y_label_spacer + metrics.y_num_width, 0);

  //draw the axis tics
  ctx.save();
  ctx.translate(0, metrics.stack_height);
  ctx.font = metrics.y_num_font;
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for (i = 0; i <= alphabet_ic; i++) {
    //draw the number
    ctx.fillText("" + i, 0, 0);
    //draw the tic
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(metrics.y_tic_width, 0);
    ctx.stroke();
    //prepare for next tic
    ctx.translate(0, -tic_height);
  }
  ctx.restore();

  ctx.translate(metrics.y_tic_width, 0);

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, metrics.stack_height);
  ctx.stroke();

  ctx.restore();
}

function draw_stack_num(ctx, metrics, row_index) {
  "use strict";
  ctx.save();
  ctx.font = metrics.x_num_font;
  ctx.translate(metrics.stack_width / 2, metrics.stack_height + metrics.x_num_above);
  ctx.save();
  ctx.rotate(-(Math.PI / 2));
  ctx.textBaseline = "middle";
  ctx.textAlign = "right";
  ctx.fillText("" + (row_index + 1), 0, 0);
  ctx.restore();
  ctx.restore();
}

function draw_stack(ctx, metrics, symbols, raster) {
  "use strict";
  var preferred_pad, sym_min, i, sym, sym_height, pad;
  preferred_pad = 0;
  sym_min = 5;

  ctx.save();//1
  ctx.translate(0, metrics.stack_height);
  for (i = 0; i < symbols.length; i++) {
    sym = symbols[i];
    sym_height = metrics.stack_height * sym.get_scale();
    
    pad = preferred_pad;
    if (sym_height - pad < sym_min) {
      pad = Math.min(pad, Math.max(0, sym_height - sym_min));
    }
    sym_height -= pad;

    //translate to the correct position
    ctx.translate(0, -(pad/2 + sym_height));
    //draw
    raster.draw(ctx, sym.get_symbol(), 0, 0, metrics.stack_width, sym_height);
    //translate past the padding
    ctx.translate(0, -(pad/2));
  }
  ctx.restore();//1
}

function draw_dashed_line(ctx, pattern, start, x1, y1, x2, y2) {
  "use strict";
  var x, y, len, i, dx, dy, tlen, theta, mulx, muly, lx, ly;
  dx = x2 - x1;
  dy = y2 - y1;
  tlen = Math.pow(dx*dx + dy*dy, 0.5);
  theta = Math.atan2(dy,dx);
  mulx = Math.cos(theta);
  muly = Math.sin(theta);
  lx = [];
  ly = [];
  for (i = 0; i < pattern; ++i) {
    lx.push(pattern[i] * mulx);
    ly.push(pattern[i] * muly);
  }
  i = start;
  x = x1;
  y = y1;
  len = 0;
  ctx.beginPath();
  while (len + pattern[i] < tlen) {
    ctx.moveTo(x, y);
    x += lx[i];
    y += ly[i];
    ctx.lineTo(x, y);
    len += pattern[i];
    i = (i + 1) % pattern.length;
    x += lx[i];
    y += ly[i];
    len += pattern[i];
    i = (i + 1) % pattern.length;
  }
  if (len < tlen) {
    ctx.moveTo(x, y);
    x += mulx * (tlen - len);
    y += muly * (tlen - len);
    ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function draw_trim_background(ctx, metrics, pspm, offset) {
  "use strict";
  var lwidth, rwidth, mwidth, rstart;
  lwidth = metrics.stack_width * pspm.get_left_trim();
  rwidth = metrics.stack_width * pspm.get_right_trim();
  mwidth = metrics.stack_width * pspm.get_motif_length();
  rstart = mwidth - rwidth;
  ctx.save();//s8
  ctx.translate(offset * metrics.stack_width, 0);
  ctx.fillStyle = "rgb(240, 240, 240)";
  if (pspm.get_left_trim() > 0) {
    ctx.fillRect(0, 0, lwidth, metrics.stack_height);
  }
  if (pspm.get_right_trim() > 0) {
    ctx.fillRect(rstart, 0, rwidth, metrics.stack_height);
  }
  ctx.fillStyle = "rgb(51, 51, 51)";
  if (pspm.get_left_trim() > 0) {
    draw_dashed_line(ctx, [3], 0, lwidth-0.5, 0, lwidth-0.5,  metrics.stack_height);
  }
  if (pspm.get_right_trim() > 0) {
    draw_dashed_line(ctx, [3], 0, rstart+0.5, 0, rstart+0.5,  metrics.stack_height);
  }
  ctx.restore();//s8
}

function size_logo_on_canvas(logo, canvas, show_names, scale) {
  "use strict";
  var draw_name, metrics;
  draw_name = (typeof show_names === "boolean" ? show_names : (logo.get_rows() > 1));
  if (canvas.width !== 0 && canvas.height !== 0) {
    return;
  }
  metrics = new LogoMetrics(canvas.getContext('2d'), 
      logo.get_columns(), logo.get_rows(), draw_name);
  if (typeof scale == "number") {
    //resize the canvas to fit the scaled logo
    canvas.width = metrics.summed_width * scale;
    canvas.height = metrics.summed_height * scale;
  } else {
    if (canvas.width === 0 && canvas.height === 0) {
      canvas.width = metrics.summed_width;
      canvas.height = metrics.summed_height;
    } else if (canvas.width === 0) {
      canvas.width = metrics.summed_width * (canvas.height / metrics.summed_height);
    } else if (canvas.height === 0) {
      canvas.height = metrics.summed_height * (canvas.width / metrics.summed_width);
    }
  }
}

function draw_logo_on_canvas(logo, canvas, show_names, scale) {
  "use strict";
  var draw_name, ctx, metrics, raster, pspm_i, pspm, 
      offset, col_index, motif_position;
  draw_name = (typeof show_names === "boolean" ? show_names : (logo.get_rows() > 1));
  ctx = canvas.getContext('2d');
  //assume that the user wants the canvas scaled equally so calculate what the best width for this image should be
  metrics = new LogoMetrics(ctx, logo.get_columns(), logo.get_rows(), draw_name);
  if (typeof scale == "number") {
    //resize the canvas to fit the scaled logo
    canvas.width = metrics.summed_width * scale;
    canvas.height = metrics.summed_height * scale;
  } else {
    if (canvas.width === 0 && canvas.height === 0) {
      scale = 1;
      canvas.width = metrics.summed_width;
      canvas.height = metrics.summed_height;
    } else if (canvas.width === 0) {
      scale = canvas.height / metrics.summed_height;
      canvas.width = metrics.summed_width * scale;
    } else if (canvas.height === 0) {
      scale = canvas.width / metrics.summed_width;
      canvas.height = metrics.summed_height * scale;
    } else {
      scale = Math.min(canvas.width / metrics.summed_width, canvas.height / metrics.summed_height);
    }
  }
  // cache the raster based on the assumption that we will be drawing a lot
  // of logos the same size
  if (typeof draw_logo_on_canvas.raster_scale === "number" && 
      Math.abs(draw_logo_on_canvas.raster_scale - scale) < 0.1) {
    raster = draw_logo_on_canvas.raster_cache;
  } else {
    raster = new RasterizedAlphabet(logo.alphabet, metrics.stack_font, metrics.stack_width * scale * 2);
    draw_logo_on_canvas.raster_cache = raster;
    draw_logo_on_canvas.raster_scale = scale;
  }
  ctx = canvas.getContext('2d');
  ctx.save();//s1
  ctx.scale(scale, scale);
  ctx.save();//s2
  ctx.save();//s7
  //create margin
  ctx.translate(metrics.pad_left, metrics.pad_top);
  for (pspm_i = 0; pspm_i < logo.get_rows(); ++pspm_i) {
    pspm = logo.get_pspm(pspm_i);
    offset = logo.get_offset(pspm_i);
    //optionally draw name if this isn't the last row or is the only row 
    if (draw_name && (logo.get_rows() == 1 || pspm_i != (logo.get_rows()-1))) {
      ctx.save();//s4
      ctx.translate(metrics.summed_width/2, metrics.name_height);
      ctx.font = metrics.name_font;
      ctx.textAlign = "center";
      ctx.fillText(pspm.name, 0, 0);
      ctx.restore();//s4
      ctx.translate(0, metrics.name_height + 
          Math.min(0, metrics.name_spacer - metrics.y_num_height/2));
    }
    //draw scale
    draw_scale(ctx, metrics, logo.alphabet.get_ic());
    ctx.save();//s5
    //translate across past the scale
    ctx.translate(metrics.y_label_height + metrics.y_label_spacer + 
        metrics.y_num_width + metrics.y_tic_width, 0);
    //draw the trimming background
    if (pspm.get_left_trim() > 0 || pspm.get_right_trim() > 0) {
      draw_trim_background(ctx, metrics, pspm, offset);
    }
    //draw letters
    ctx.translate(0, metrics.y_num_height / 2);
    for (col_index = 0; col_index < logo.get_columns(); col_index++) {
      ctx.translate(metrics.stack_pad_left,0);
      if (col_index >= offset && col_index < (offset + pspm.get_motif_length())) {
        motif_position = col_index - offset;
        draw_stack_num(ctx, metrics, motif_position);
        draw_stack(ctx, metrics, pspm.get_stack(motif_position, logo.alphabet), raster);
      }
      ctx.translate(metrics.stack_width, 0);
    }
    ctx.restore();//s5
    ////optionally draw name if this is the last row but isn't the only row 
    if (draw_name && (logo.get_rows() != 1 && pspm_i == (logo.get_rows()-1))) {
      //translate vertically past the stack and axis's        
      ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
          Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width + metrics.name_spacer));

      ctx.save();//s6
      ctx.translate(metrics.summed_width/2, metrics.name_height);
      ctx.font = metrics.name_font;
      ctx.textAlign = "center";
      ctx.fillText(pspm.name, 0, 0);
      ctx.restore();//s6
      ctx.translate(0, metrics.name_height);
    } else {
      //translate vertically past the stack and axis's        
      ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
          Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width));
    }
    //if not the last row then add middle padding
    if (pspm_i != (logo.get_rows() -1)) {
      ctx.translate(0, metrics.pad_middle);
    }
  }
  ctx.restore();//s7
  ctx.translate(metrics.summed_width - metrics.pad_right, metrics.summed_height - metrics.pad_bottom);
  ctx.font = metrics.fine_txt_font;
  ctx.textAlign = "right";
  ctx.fillText(logo.fine_text, 0,0);
  ctx.restore();//s2
  ctx.restore();//s1
}

function create_canvas(c_width, c_height, c_id, c_title, c_display) {
  "use strict";
  var canvas = document.createElement("canvas");
  //check for canvas support before attempting anything
  if (!canvas.getContext) {
    return null;
  }
  var ctx = canvas.getContext('2d');
  //check for html5 text drawing support
  if (!supports_text(ctx)) {
    return null;
  }
  //size the canvas
  canvas.width = c_width;
  canvas.height = c_height;
  canvas.id = c_id;
  canvas.title = c_title;
  canvas.style.display = c_display;
  return canvas;
}

function logo_1(alphabet, fine_text, pspm) {
  "use strict";
  var logo = new Logo(alphabet, fine_text);
  logo.add_pspm(pspm);
  return logo;
}

function logo_2(alphabet, fine_text, target, query, query_offset) {
  "use strict";
  var logo = new Logo(alphabet, fine_text);
  if (query_offset < 0) {
    logo.add_pspm(target, -query_offset);
    logo.add_pspm(query);
  } else {
    logo.add_pspm(target);
    logo.add_pspm(query, query_offset);
  }      
  return logo;
}

/*
 * Specifies an alternate source for an image.
 * If the image with the image_id specified has
 * not loaded then a generated logo will be used 
 * to replace it.
 *
 * Note that the image must either have dimensions
 * or a scale must be set.
 */
function alternate_logo(logo, image_id, scale) {
  "use strict";
  var image = document.getElementById(image_id);
  if (!image) {
    alert("Can't find specified image id (" +  image_id + ")");
    return;
  }
  //if the image has loaded then there is no reason to use the canvas
  if (image_ok(image)) {
    return;
  }
  //the image has failed to load so replace it with a canvas if we can.
  var canvas = create_canvas(image.width, image.height, image_id, image.title, image.style.display);
  if (canvas === null) {
    return;
  }
  //draw the logo on the canvas
  draw_logo_on_canvas(logo, canvas, null, scale);
  //replace the image with the canvas
  image.parentNode.replaceChild(canvas, image);
}

/*
 * Specifes that the element with the specified id
 * should be replaced with a generated logo.
 */
function replace_logo(logo, replace_id, scale, title_txt, display_style) {
  "use strict";
  var element = document.getElementById(replace_id);
  if (!replace_id) {
    alert("Can't find specified id (" + replace_id + ")");
    return;
  }
  //found the element!
  var canvas = create_canvas(50, 120, replace_id, title_txt, display_style);
  if (canvas === null) {
    return;
  }
  //draw the logo on the canvas
  draw_logo_on_canvas(logo, canvas, null, scale);
  //replace the element with the canvas
  element.parentNode.replaceChild(canvas, element);
}

/*
 * Fast string trimming implementation found at
 * http://blog.stevenlevithan.com/archives/faster-trim-javascript
 *
 * Note that regex is good at removing leading space but
 * bad at removing trailing space as it has to first go through
 * the whole string.
 */
function trim (str) {
  "use strict";
  var ws, i;
  str = str.replace(/^\s\s*/, '');
  ws = /\s/; i = str.length;
  while (ws.test(str.charAt(--i)));
  return str.slice(0, i + 1);
}

    </script>
    <script type="text/javascript">
var LEGEND_LINE = 16;
var LEGEND_FONT = "Helvetica";
var LEGEND_PAD = 5;

var Dasher = function(ctx, start_x, start_y, pattern) {
  if (typeof pattern === "undefined") pattern = [];
  this.ctx = ctx;
  this.x = start_x;
  this.y = start_y;
  this.pattern = pattern;
  this.index = 0;     // where in the pattern are we up to?
  this.fragment = 0;  // how much of the current pattern have we drawn
  this.on = true;     // pen on paper?
  ctx.moveTo(start_x, start_y);
};

Dasher.prototype.dashTo = function(x, y) {
  var dx = x - this.x;
  var dy = y - this.y;
  var d = Math.pow(dx * dx + dy * dy, 0.5);
  if (this.pattern.length == 0) {
    // when no pattern is specified this just draws lines
    this.ctx.lineTo(x, y);
  } else {
    // calculate distance to complete dash
    var dc = this.pattern[this.index] - this.fragment;
    while (dc <= d) {
      // calculate the fraction of the line needed
      var f = dc / d;
      this.x += dx * f;
      this.y += dy * f;
      if (this.on) {
        this.ctx.lineTo(this.x, this.y);
      } else {
        this.ctx.moveTo(this.x, this.y);
      }
      // move to the next dash
      this.fragment = 0;
      // skip empty dashes, just toggling on state
      do {
        this.index = (this.index + 1) % this.pattern.length;
        this.on = !this.on;
      } while (this.pattern[this.index] <= 0);
      // update variables
      dc = this.pattern[this.index];
      dx = x - this.x;
      dy = y - this.y;
      d = Math.pow(dx * dx + dy * dy, 0.5);
    }
    this.fragment += d;
    this.x = x;
    this.y = y;
    if (this.on) {
      this.ctx.lineTo(this.x, this.y);
    } else {
      this.ctx.moveTo(this.x, this.y);
    }
  }
}

var CentrimoResult = function(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts) {
  "use strict";
  if (typeof name === "undefined") {
    name = "";
  }
  if (typeof sig === "undefined") {
    sig = "";
  }
  if (typeof colour == "undefined") {
    colour = "#000000";
  }
  this.name = name;
  this.sig = sig;
  this.colour = colour;
  this.motif_length = motif_length;
  this.total_sites = total_sites;
  this.site_counts = site_counts;
  this.has_neg = (typeof neg_total_sites === "number" && 
      typeof neg_site_counts === "object" && neg_site_counts instanceof Array);
  this.neg_total_sites = neg_total_sites;
  this.neg_site_counts = neg_site_counts;
};

/*
 * CentrimoRSet
 * Construct a centrimo result set.
 */
var CentrimoRSet = function(sequence_length) {
  "use strict";
  this.sequence_length = sequence_length;
  this.results = [];
};

/*
 * seq_len
 * Get the sequence length of the result set.
 */
CentrimoRSet.prototype.seq_len = function() {
  "use strict";
  return this.sequence_length;
};

/*
 * add
 * Add a centrimo result to the set
 */
CentrimoRSet.prototype.add = function(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts) {
  "use strict";
  this.results.push(new CentrimoResult(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts));
};

/*
 * count
 * Return the count of centrimo results.
 */
CentrimoRSet.prototype.count = function() {
  "use strict";
  return this.results.length;
};

/*
 *  get
 *  Get an entry in the result set.
 */
CentrimoRSet.prototype.get = function(index) {
  "use strict";
  return this.results[index];
};

/*
 * CentrimoLine
 */
var CentrimoLine = function(name, sig, colour, dash, thickness, show_on_legend, xlist, ylist) {
  "use strict";
  if (xlist.length != ylist.length) {
    throw new Error("The list of x and y points must be the same length.");
  }
  this.xlist = xlist;
  this.ylist = ylist;
  this.name = name;
  this.sig = sig;
  this.colour = colour;
  this.dash = dash;
  this.thickness = thickness;
  this.show_on_legend = show_on_legend;
  this.max_prob = -1;
};

/*
 * trim
 *
 * Removes points from the ends so the lines are the same length.
 */
CentrimoLine.prototype.trim = function(left, right) {
  "use strict";
  var lefti, righti, gradient, gap, left_y, right_y;
  if (typeof left !== "number"|| isNaN(left)) {
    throw new Error("left trim is not a number");
  }
  if (typeof right !== "number" || isNaN(right)) {
    throw new Error("right trim is not a number");
  }
  for (lefti = 0; lefti < this.xlist.length; lefti++) {
    if (this.xlist[lefti] >= left) {
      break;
    }
  }
  if (lefti === 0 && this.xlist[0] !== left) {
    throw new Error("Attempt to undertrim line.");
  }
  for (righti = this.xlist.length - 1; righti >= 0; righti--) {
    if (this.xlist[righti] <= right) {
      break;
    }
  }
  if (righti === (this.xlist.length - 1) && this.xlist[righti] !== right) {
    throw new Error("Attempt to undertrim line.");
  }
  if (lefti == this.xlist.length || righti == -1) {
    // all points outside of drawable region
    this.xlist = [];
    this.ylist = [];
    return;
  }
  if (this.xlist[lefti] != left) {
    // create a new point that is exactly at left by interpolating
    gradient = (this.ylist[lefti] - this.ylist[lefti-1]) / 
      (this.xlist[lefti] - this.xlist[lefti-1]);
    gap = left - this.xlist[lefti-1];
    left_y = this.ylist[lefti-1] + gradient * gap;
    this.xlist.splice(0, lefti, left);
    this.ylist.splice(0, lefti, left_y);
    righti = righti - lefti + 1;
  } else {
    this.xlist.splice(0, lefti);
    this.ylist.splice(0, lefti);
    righti -= lefti;
  }
  if (this.xlist[righti] != right) {
    // create a new point that is exactly at right by interpolating
    gradient = (this.ylist[righti + 1] - this.ylist[righti]) /
      (this.xlist[righti + 1] - this.xlist[righti]);
    gap = right - this.xlist[righti];
    right_y = this.ylist[righti] + gradient * gap;
    // truncate the lists
    this.xlist.length = righti + 1;
    this.ylist.length = righti + 1;
    // push the new item on the end of the lists
    this.xlist.push(right);
    this.ylist.push(right_y);
  } else {
    // truncate the lists
    this.xlist.length = righti + 1;
    this.ylist.length = righti + 1;
  }
  this.max_prob = -1;
};

CentrimoLine.prototype.max = function() {
  "use strict";
  var y_max, i;
  if (this.max_prob != -1) {
    return this.max_prob;
  }
  y_max = 0;
  for (i = 0; i < this.xlist.length; i++) {
    if (this.ylist[i] > y_max) {
      y_max = this.ylist[i];
    }
  }
  this.max_prop = y_max;
  return this.max_prop;
};

/*
 * CentrimoScale
 *
 * Calculates the increments on the y axis
 */
var CentrimoScale = function(max_prob) {
  "use strict";
  var decimals, inc, rounder, max, inc_plus;
  if (max_prob === 0) {
    this.max = 0.01;
    this.inc = 0.002;
    this.digits = 3;
    return;
  }
  // find the minimum number of decimals needed to display the largest
  // digit of the maximum probability
  decimals = Math.ceil(-(Math.log(max_prob) / Math.log(10)));
  // calculate an increment which is (at minimum) 10 times smaller the the max
  inc = Math.pow(10, -(decimals+1));
  // round-up the maximum probabilty to its largest digit
  rounder = Math.pow(10, decimals);
  max = Math.ceil(max_prob * rounder) / rounder;
  // adjust the increment so it's between 5 and 12 times the maximum
  // probability
  if (inc * 5 < max && inc * 12 > max) {
    inc *= 1;
  } else if (inc * 10 < max && inc * 24 > max) {
    inc *= 2;
  } else if (inc * 25 < max && inc * 60 > max) {
    inc *= 5;
  } else if (inc * 50 < max && inc * 120 > max) {
    inc *= 10;
  }
  max += inc;
  inc_plus = (1.125 * inc);
  while (max - inc_plus > max_prob) {
    max -= inc;
  }
  this.max = max;
  this.inc = inc;
  this.digits = decimals+1;
};

var CentrimoLegendMetrics = function(lw, lh, id_w, pv_w, sq_w) {
  "use strict";
  this.width = lw;
  this.height = lh;
  this.id_width = id_w;
  this.pv_width = pv_w;
  this.sq_width = sq_w;
};

var CentrimoGraphMetrics = function(legend_metrics, top_edge, bottom_edge,
    left_mark, left_val, right_mark, right_val) {
  if (typeof legend_metrics !== "object" || legend_metrics === null) {
    this.legend_width = 10;
    this.legend_height = 10;
  } else {
    this.legend_width = legend_metrics.width;
    this.legend_height = legend_metrics.height;
  }
  this.top_edge = top_edge;
  this.bottom_edge = bottom_edge;
  this.left_mark = left_mark;
  this.left_val = left_val;
  this.right_mark = right_mark;
  this.right_val = right_val;
};

/*
 * CentrimoGraph
 * Takes a results set and a window weight array and produces a graph. 
 * The weights in the window_weights should be non-negative and sum to 1.
 */
var CentrimoGraph = function(rset, window_weights, fine_text, start, end) {
  "use strict";
  var trim_left, trim_right, i, j, k, result, x, y, xpos, ypos, positions;
  var y_neg, ypos_neg, line_thickness;

  line_thickness = (window_weights.length < 10 ? 1 : 3);
  if (typeof fine_text !== "string") {
    fine_text = "";
  }
  this.fine_text = fine_text;
  this.lines = [];
  for (i = 0; i < rset.count(); i++) {
    result = rset.get(i);
    x = [];
    y = [];
    if (result.has_neg) {
      y_neg = [];
    }
    xpos = (result.motif_length - rset.seq_len() + window_weights.length) / 2;
    if (typeof trim_left === "undefined") {
      trim_left = xpos;
    } else if (trim_left < xpos) {
      trim_left = xpos;
    }
    positions = result.site_counts.length - window_weights.length + 1;
    for (j = 0; j < positions; j++, xpos += 1) {
      ypos = 0;
      // avoid division by zero when no sites are found
      if (result.total_sites > 0) {
        for (k = 0; k < window_weights.length; k++) {
          ypos += window_weights[k] * result.site_counts[j + k];
        }
        ypos /= result.total_sites;
      }
      x.push(xpos);
      y.push(ypos);
      // handle the negative dataset
      if (result.has_neg) {
        ypos_neg = 0;
        if (result.neg_total_sites > 0) {
          for (k = 0; k < window_weights.length; k++) {
            ypos_neg += window_weights[k] * result.neg_site_counts[j + k];
          }
          ypos_neg /= result.neg_total_sites;
        }
        y_neg.push(ypos_neg);
      }
    }
    this.lines.push(new CentrimoLine(result.name, result.sig, result.colour, [], line_thickness, true, x, y));
    if (result.has_neg) {
      this.lines.push(new CentrimoLine(result.name, result.sig, result.colour, [6,4], 2, false, x.slice(0), y_neg));
    }
    if (positions > 0) {
      if (typeof trim_right === "undefined") {
        trim_right = xpos - 1;
      } else if (trim_right > (xpos - 1)) {
        trim_right = xpos - 1;
      }
    }
  }
  if (typeof start !== "undefined") {
    if (start > trim_left) {
      trim_left = start;
    }
    this.start = start;
  } else {
    this.start = -Math.ceil(rset.seq_len() / 2);
  }
  if (typeof end !== "undefined") {
    if (end < trim_right) {
      trim_right = end;
    }
    this.end = end;
  } else {
    this.end = Math.floor(rset.seq_len() / 2);
  }
  this.max_prob = 0;
  for (i = 0; i < this.lines.length; i++) {
    this.lines[i].trim(trim_left, trim_right);
    this.max_prob = Math.max(this.max_prob, this.lines[i].max());
  }
  this.scale = new CentrimoScale(this.max_prob);
};

/*
 * draw_graph
 *
 * Draws a motif probability graph
 */
CentrimoGraph.prototype.draw_graph = function (ctx, w, h, draw_legend, legend_x, legend_y) {
  "use strict";
  var gap, l_margin, t_margin, b_margin, r_margin, legend_metrics, 
      legend_width, legend_height;
  gap = 10;
  l_margin = gap + 30 + 10 * (2 + this.scale.digits);
  t_margin = 20;
  b_margin = 60;
  r_margin = 10;
  legend_metrics = this.measure_legend(ctx);
  // setting global
  legend_width = legend_metrics.width;
  legend_height = legend_metrics.height;
  // constrain legend to within graph area
  legend_x = Math.round(legend_x);
  legend_y = Math.round(legend_y);
  if (legend_x < (l_margin + gap)) {
    legend_x = l_margin + gap;
  } else if ((legend_x + legend_metrics.width) > (w - r_margin - gap)) {
    legend_x = w - r_margin - legend_metrics.width - gap;
  }
  if (legend_y < (t_margin + gap)) {
    legend_y = t_margin + gap;
  } else if ((legend_y + legend_metrics.height) > (h - b_margin - gap)) {
    legend_y = h - b_margin - legend_metrics.height - gap;
  }

  // draw graph
  ctx.save();
  // draw border
  ctx.beginPath();
  ctx.moveTo(l_margin - 0.5, t_margin +0.5);
  ctx.lineTo(l_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, t_margin +0.5);
  ctx.closePath();
  ctx.stroke();
  // draw fineprint
  ctx.save();
  ctx.font = "9px Helvetica";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  ctx.fillText(this.fine_text, w - 1, h - 2);
  ctx.restore();
  // draw y axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_y_axis(ctx, 0, h - (t_margin + b_margin));
  ctx.restore();
  // draw y labels
  ctx.save();
  ctx.translate(gap, t_margin);
  this.draw_y_axis_label(ctx, l_margin, h - (t_margin + b_margin));
  ctx.restore();
  // draw x axis
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis(ctx, w - (l_margin + r_margin), b_margin);
  ctx.restore();
  // draw top axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_top_axis(ctx, w - (l_margin + r_margin), 0);
  ctx.restore();
  // draw x axis labels
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis_label(ctx, w - (l_margin + r_margin), b_margin - gap);
  ctx.restore();
  // draw lines
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_lines(ctx, w - (l_margin + r_margin), h - (t_margin + b_margin), 8);
  ctx.restore();
  // draw legend
  if (draw_legend) { 
    ctx.save();
    ctx.translate(legend_x, legend_y);
    this.draw_legend(ctx, legend_metrics);
    ctx.restore();
  }
  ctx.restore();
  return new CentrimoGraphMetrics(legend_metrics, t_margin, h - b_margin,
      l_margin, this.start, w - r_margin, this.end);
};

/*
 * draw_x_axis
 *
 * TODO this currently only supports symmetrical graphs
 * and needs to be updated.
 */
CentrimoGraph.prototype.draw_x_axis = function(ctx, w, h) {
  "use strict";
  var length, tick_max, nticks, tick_inc, scale_x, i, x;
  ctx.save();
  ctx.translate(w / 2, 0);
  length = this.end - this.start;
  tick_max = length / 2;
  nticks = 5;
  tick_inc = Math.round(tick_max / (10*nticks)) * 10;
  scale_x = w / length;
  ctx.beginPath();
  ctx.moveTo(0.5, -5);
  ctx.lineTo(0.5, 3);
  ctx.stroke();
  ctx.font = "14pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText("0", 0, 5);
  for (i = tick_inc; i < tick_max; i += tick_inc) {
    x = Math.round(i * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, -5);
    ctx.lineTo(x, 3);
    ctx.stroke();
    ctx.fillText(""+i, x, 5);
    ctx.beginPath();
    ctx.moveTo(-x, -5);
    ctx.lineTo(-x, 3);
    ctx.stroke();
    ctx.fillText(""+(-i), -x, 5);
  }
  ctx.restore();
};

/*
 * draw_top_axis
 *
 * TODO this currently only supports symmetrical graphs.
 */
CentrimoGraph.prototype.draw_top_axis = function(ctx, w, h) {
  "use strict";
  var length, tick_max, scale_x, i, x;
  ctx.save();
  ctx.translate(w / 2, 0);
  length = this.end - this.start;
  tick_max = length / 2;
  scale_x = w / length;
  ctx.beginPath();
  ctx.moveTo(0.5, 0);
  ctx.lineTo(0.5, 8);
  ctx.stroke();
  for (i = 50; i < tick_max; i += 50) {
    x = Math.round(i * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 8);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-x, 0);
    ctx.lineTo(-x, 8);
    ctx.stroke();
  }
  ctx.restore();
};

/*
 * draw_x_axis_label
 */
CentrimoGraph.prototype.draw_x_axis_label = function(ctx, w, h) {
  "use strict";
  ctx.save();
  ctx.font = "14pt Helvetica";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText("Position of Best Site in Sequence", w/2, h);
  ctx.restore();
};

/*
 * draw_y_axis
 *
 * TODO some work needs to be done to allow moving the zero
 */
CentrimoGraph.prototype.draw_y_axis = function(ctx, w, h) {
  "use strict";
  var y_scale, p, y;
  ctx.save();
  ctx.font = "14pt Helvetica";
  ctx.textBaseline = "middle";
  ctx.textAlign = "right";

  y_scale = h / this.scale.max;
  for (p = 0; p < this.scale.max; p += this.scale.inc) {
    y = Math.round(h - p * y_scale) + 0.5;
    this.draw_y_tic(ctx, this.scale.digits, y, p);
  }
  this.draw_y_tic(ctx, this.scale.digits, 0.5, this.scale.max);

  ctx.restore();
};

/*
 * draw_y_tic
 */
CentrimoGraph.prototype.draw_y_tic = function(ctx, digits, y, p) {
  "use strict";
  ctx.beginPath();
  ctx.moveTo(5, y);
  ctx.lineTo(-3, y);
  ctx.stroke();
  ctx.fillText(p.toFixed(digits), -5, y);
};

/*
 * draw_y_axis_label
 */
CentrimoGraph.prototype.draw_y_axis_label = function(ctx, w, h) {
  "use strict";
  ctx.save();
  ctx.translate(0, h/2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = "14pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText("Probability", 0, 0);
  ctx.restore();
};

/*
 * draw_lines
 */
CentrimoGraph.prototype.draw_lines = function(ctx, w, h, tic_size) {
  "use strict";
  var scale_y, scale_x, i, line, x_points, y_points, j, x, y, dasher;
  if (typeof tic_size === "undefined") {
    tic_size = 0;
  }
  scale_y = h / this.scale.max;
  scale_x = w / (this.end - this.start);
  ctx.save();
  ctx.translate((-this.start) * scale_x, 0);
  ctx.strokeStyle = '#DDD';
  ctx.beginPath();
  ctx.moveTo(0.5, tic_size);
  ctx.lineTo(0.5, h - tic_size);
  ctx.stroke();
  ctx.restore();
  ctx.save();
  ctx.lineJoin = "bevel";
  ctx.miterLimit = 0;
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    ctx.lineWidth = line.thickness;
    x_points = line.xlist;
    y_points = line.ylist;
    ctx.strokeStyle = line.colour;
    ctx.beginPath();
    for (j = 0; j < x_points.length; j++) {
      if (isNaN(x_points[j])) {
        throw new Error("X NaN!");
      }
      if (isNaN(y_points[j])) {
        throw new Error("Y NaN!");
      }
      x = (x_points[j] - this.start) * scale_x;
      y = h - y_points[j] * scale_y;
      if (j === 0) {
        dasher = new Dasher(ctx, x, y, line.dash);
      } else {
        dasher.dashTo(x, y);
      }
    }
    ctx.stroke();
  }
  ctx.restore();
};

/*
 * measure_legend
 */
CentrimoGraph.prototype.measure_legend = function(ctx) {
  "use strict";
  var lw, lh, sq_w, id_w, pv_w, lines, i, line, len;
  // initilise the line height to the size of the padding
  lh = 2 * LEGEND_PAD;
  // calculate the column widths
  sq_w = LEGEND_LINE - 2;
  id_w = 0;
  pv_w = 0;
  ctx.save();
  ctx.font = "" + LEGEND_LINE + "px " + LEGEND_FONT; 
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    if (!line.show_on_legend) {
      continue;
    }
    lh += LEGEND_LINE * 1.2;
    len = ctx.measureText(line.name).width;
    if (id_w < len) {
      id_w = len;
    }
    len = ctx.measureText(line.sig).width;
    if (pv_w < len) {
      pv_w = len;
    }
  }
  lh = Math.round(lh);
  ctx.restore();
  // legend width is a function of the column widths
  lw = id_w + pv_w + sq_w + 4 * LEGEND_PAD;

  return new CentrimoLegendMetrics(lw, lh, id_w, pv_w, sq_w);
};

/*
 * draw_legend
 */
CentrimoGraph.prototype.draw_legend = function(ctx, metrics) {
  "use strict";
  var ln_h, pad, w, h, id_w, pv_w, sq_w, id_x, pv_x, sq_x, i, line;
  if (this.lines.length === 0) {
    return;
  }
  ln_h = LEGEND_LINE;
  pad = LEGEND_PAD;
  w = metrics.width;
  h = metrics.height;
  id_w = metrics.id_width;
  pv_w = metrics.pv_width;
  sq_w = metrics.sq_width;
  id_x = 0;
  pv_x = id_x + id_w + pad;
  sq_x = pv_x + pv_w + pad;

  ctx.save();
  ctx.font = "" + ln_h + "px " + LEGEND_FONT;
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  // draw it
  ctx.save();
  ctx.fillStyle = 'white';
  ctx.fillRect(0.5, 0.5, w-1, h-1);
  ctx.strokeStyle = 'black';
  ctx.strokeRect(0.5, 0.5, w-1, h-1);
  ctx.restore();
  ctx.translate(pad, pad);
  ctx.fillStyle = "black";
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    if (!line.show_on_legend) {
      continue;
    }
    ctx.translate(0, ln_h);
    ctx.save();
    ctx.fillStyle = line.colour;
    ctx.fillRect(sq_x, -sq_w + 0.1 * ln_h, sq_w, sq_w);
    ctx.restore();
    ctx.fillText(line.name, id_x, 0);
    ctx.fillText(line.sig, pv_x, 0);
    ctx.translate(0, 0.2 * ln_h);
  }
  ctx.restore();
};

/*
 * triangular_weights
 * Returns an array of length n containing normalized weights.
 *
 */
function triangular_weights(n) {
  "use strict";
  var weights, half, half_i, sum, i, unscaled_weight;
  weights = [];
  half = n/2;
  half_i = Math.floor(half);
  sum = 0;
  for (i = 0; i < half_i; i++) {
    unscaled_weight = (i + 0.5) / half;
    weights[i] = unscaled_weight;
    weights[n - i -1] = unscaled_weight;
    sum += 2 * unscaled_weight;
  }
  if (n % 2 == 1) {
    weights[half_i] = 1;
    sum += 1;
  }
  // normalize
  for (i = 0; i < n; i++) {
    weights[i] /= sum;
  }
  return weights;
}

/*
 * uniform_weights
 * Returns an array of length n containing normalized weights.
 *
 */
function uniform_weights(n) {
  "use strict";
  var weights, weight, i;
  weights = [];
  weight = 1.0 / n;
  for (i = 0; i < n; i++) {
    weights[i] = weight;
  }
  return weights;
}

    </script>
    <script type="text/javascript">
var palate = ["white", "cyan", "blue", "#FF00FF", "#00FF00", "red", "orange", "#008000", "#8A2BE2", "black"];
var text_palate = ["black", "black", "white", "white", "black", "white", "black", "white", "white", "white"];
var INT_MAX = 9007199254740992;

var s_motifs = [];
var s_swatches = [];
var s_logos = []
var s_count = 0;
var swap = null;
var dna_alphabet = new Alphabet("ACGT", "A 0.25 C 0.25 G 0.25 T 0.25");
var logo_timer = null; // timer to draw motif when the mouse pauses on a row
var logo_motif = null; // motif to draw when timer expires
var logo_row = null; // the row (or tbody) that the mouse is over
var legend_x = 1000;
var legend_y = 1000;
var union_seq_ids = [];
var intersect_seq_ids = [];
var graph_metrics = new CentrimoGraphMetrics(null, 0, 0, 0, 0, 0, 0);

pre_load_setup();


/*
 * name_from_source
 *
 * Makes a file name more human friendly to read.
 */
function name_from_source(source) {
  "use strict";
  var file, noext;
  if (source == "-") {
    return "-"
  }
  //assume source is a file name
  file = source.replace(/^.*\/([^\/]+)$/,"$1");
  noext = file.replace(/\.[^\.]+$/, "");
  return noext.replace(/_/g, " ");
}


//
// See http://stackoverflow.com/questions/814613/how-to-read-get-data-from-a-url-using-javascript
// Slightly modified with information from
// https://developer.mozilla.org/en/DOM/window.location
//
function parse_params() {
  "use strict";
  var search, queryStart, queryEnd, query, params, nvPairs, i, nv, n, v;
  search = window.location.search;
  queryStart = search.indexOf("?") + 1;
  queryEnd   = search.indexOf("#") + 1 || search.length + 1;
  query      = search.slice(queryStart, queryEnd - 1);

  if (query === search || query === "") return {};

  params  = {};
  nvPairs = query.replace(/\+/g, " ").split("&");

  for (i = 0; i < nvPairs.length; i++) {
    nv = nvPairs[i].split("=");
    n  = decodeURIComponent(nv[0]);
    v  = decodeURIComponent(nv[1]);
    // allow a name to be used multiple times
    // storing each value in the array
    if (!(n in params)) {
      params[n] = [];
    }
    params[n].push(nv.length === 2 ? v : null);
  }
  return params;
}

/*
 * pre_load_setup
 *
 *  Sets up initial variables which may be
 *  required for the HTML document creation.
 */
function pre_load_setup() {
  "use strict";
  var i, motifs, params, showlist, show, parts, db_i, id, j, motif;
  var seq_db, db, dbs, sites, max_site, max_site_pos;
  for (i = 0; i < palate.length -1; i++) {
    s_motifs[i] = null;
    s_swatches[i] = null;
    s_logos[i] = null;
  }
  s_count = 0;
  motifs = data["motifs"];
  motifs.sort(sort_motif_evalue);
  // put a copy of the best evalue in the motif
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    motif["best_log_adj_pvalue"] = motif["peaks"][0]["log_adj_pvalue"];
    // calculate the best probability
    max_site = 0;
    max_site_pos = 0;
    sites = motif["sites"];
    for (j = 0; j < sites.length; j++) {
      if (sites[j] > max_site) {
        max_site = sites[j];
        max_site_pos = j;
      }
    }
    motif["max_prob"] = max_site / motif["total_sites"];
    motif["max_prob_loc"] = max_site_pos + (motif["len"] / 2) - (data["seqlen"] / 2);
  }
  params = parse_params();
  if (params["show"]) {
    showlist = params["show"];
    for (i = 0; i < showlist.length; i++) {
      show = showlist[i];
      parts = show.match(/^db(\d+) (.+)$/);
      db_i = parseInt(parts[1]);
      id = parts[2];
      // loop over the motifs looking for a match
      for (j = 0; j < motifs.length; j++) {
        motif = motifs[j];
        if (motif["db"] == db_i && motif["id"] == id) {
          motif["colouri"] = s_count + 1;
          s_motifs[s_count] = motif;
          s_count++;
          break;
        }
      }
      // give up if we've used all the available colours
      if ((s_count + 1) >= palate.length) break; 
    }
  } else {
    s_count = Math.min(3, motifs.length);
    for (i = 0; i < s_count; i++) {
      motif = motifs[i];
      motif["colouri"] = i+1;
      s_motifs[i] = motif;
    }
  }
  calculate_seq_ids();
  // get the name of the sequence db
  seq_db = data['sequence_db'];
  if (!seq_db['name']) seq_db['name'] = name_from_source(seq_db['source']);
  // get the names of the motif databases
  dbs = data['motif_dbs'];
  for (i = 0; i < dbs.length; i++) {
    db = dbs[i];
    if (!db['name']) db['name'] = name_from_source(db['source']);
  }
}

function num_keys(e) {
  if (!e) var e = window.event;
  var code = (e.keyCode ? e.keyCode : e.which);
  var keychar = String.fromCharCode(code);
  var numre = /\d/;
  // only allow 0-9 and various control characters (Enter, backspace, delete)
  if (code != 8 && code != 9 && code != 13 && code != 46 && !numre.test(keychar)) {
    e.preventDefault();
  }
}

/*
 * toggle_column
 *
 * Adds or removes a class from the table displaying the 
 * centrally enriched motifs. This is primary used to set the visibility
 * of columns by using css rules. If the parameter 'show' is not passed
 * then the existence of the class will be toggled, otherwise it will be
 * included if show is false.
 */
function toggle_column(cls) {
  toggle_class($("motifs"), cls);
}

/*
 * toggle_filter
 *
 * Called when the user clicks a checkbox
 * to enable/disable a filter option.
 */
function toggle_filter(chkbox, filter_id) {
  var filter = $(filter_id);
  filter.disabled = !(chkbox.checked);
  if (!filter.disabled) {
    filter.focus();
    if (filter.select) filter.select();
  }
}

/*
 * enable_filter
 *
 * Called when the user clicks a filter label.
 * Enables the filter.
 */
function enable_filter(chkbox_id, filter_id) {
  var chkbox = $(chkbox_id);
  if (!chkbox.checked) {
    var filter = $(filter_id);
    $(chkbox_id).checked = true;
    filter.disabled = false;
    filter.focus();
    if (filter.select) filter.select();
  }
}

/*
 * update_filter
 *
 * If the key event is an enter key press then
 * update the filter on the CEM table
 */
function update_filter(e) {
  if (!e) var e = window.event;
  var code = (e.keyCode ? e.keyCode : e.which);
  if (code == 13) {
    e.preventDefault();
    make_CEM_table();
  }
}

/*
 * clear_selection
 *
 * Called when the user clicks the X in the
 * title of the centrally enriched motifs and
 * causes all the motifs to be deselected.
 */
function clear_selection() {
  for (var i = 1; i < palate.length; i++) {
    var motif = s_motifs[i-1];
    var swatch = s_swatches[i-1];
    s_motifs[i-1] = null;
    s_swatches[i-1] = null;
    s_logos[i-1] = null;
    if (motif) delete motif['colouri'];
    if (swatch) swatch.style.backgroundColor = palate[0];
  }
  s_count = 0;
  if (!data['options']['noseq']) {
    //reset_sequences_IDs_list();
    union_seq_ids = [];
    intersect_seq_ids = [];
    display_seq_ids();
  }
  make_PM_table();
  make_MP_graph();
}

/*
 * toggle_graph_motif
 *
 * Activated when the user clicks on a swatch in the centrally enriched motifs 
 * table. If the motif is already selected it deselects it otherwise it picks 
 * an unused colour and selects it for graphing.
 */
function toggle_graph_motif(e) {
  "use strict";
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  // in case we land on a text node
  if (swatch.nodeType == 3) swatch = swatch.parentNode;
  // find the containing tbody
  var group = find_parent(swatch.parentNode, "peak_group");
  // get the attached motif
  var motif = group['data_motif'];
  if (motif['colouri'] && motif['colouri'] != 0) {
    // deselect the motif
    var i = motif['colouri'];
    s_motifs[i-1] = null;
    s_swatches[i-1] = null;
    s_logos[i-1] = null;
    delete motif['colouri'];
    swatch.style.backgroundColor = palate[0];
    s_count--;
    if (!data['options']['noseq']) calculate_seq_ids();
  } else {
    // select an unused colour
    var i;
    for (i = 1; i < palate.length; i++) {
      if (!s_motifs[i-1]) break;
    }
    if (i == palate.length) {
      alert("All graph colours used. Please deselect motifs before adding more.");
      return;
    }
    s_motifs[i-1] = motif;
    s_swatches[i-1] = swatch;
    motif['colouri'] = i;
    swatch.style.backgroundColor = palate[i];
    s_count++;
    if (!data['options']['noseq']) {
      if (s_count == 1) {
        union_seq_ids = motif["seqs"].slice(0);
        intersect_seq_ids = union_seq_ids.slice(0);
      } else {
        union_seq_ids = union_nums(union_seq_ids, motif["seqs"]);
        intersect_nums(intersect_seq_ids, motif["seqs"]);
      }
    }
  }
  if (!data['options']['noseq']) display_seq_ids();
  make_PM_table();
  make_MP_graph();
}

/*
 * move_legend
 *
 * Called when the user clicks on the graph
 * to move the legend location.
 */
function move_legend(e) {
  var target;
  if (!e) var e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;
  var elemXY = coords(target);
  var posx = 0;
  var posy = 0;
  if (e.pageX || e.pageY)   {
    posx = e.pageX;
    posy = e.pageY;
  }
  else if (e.clientX || e.clientY)   {
    posx = e.clientX + document.body.scrollLeft
      + document.documentElement.scrollLeft;
    posy = e.clientY + document.body.scrollTop
      + document.documentElement.scrollTop;
  }
  var x = posx - elemXY[0];
  var y = posy - elemXY[1];
  legend_x = x - graph_metrics.legend_width/2;
  legend_y = y - graph_metrics.legend_height/2;
  if (parseInt($("legend").value) != 0) make_MP_graph();
}

function highlight_peak(e) {
  var target, pop;
  pop = $("pop_peak");
  if (pop.style.visibility === "visible") return;
  if (!e) var e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;
  while (!target['data_peak']) {
    if (target.nodeName == 'BODY') return;
    target = target.parentNode;
  }
  var peak = target['data_peak'];

  var l = graph_metrics.left_mark;
  var w = graph_metrics.right_mark - graph_metrics.left_mark;
  var d = graph_metrics.right_val - graph_metrics.left_val;
  var unit = w / d;

  pop.style.width = (peak["spread"] * unit) + "px";
  pop.style.left = (l + (((peak["center"] - (peak["spread"] / 2)) - graph_metrics.left_val) * unit)) + "px";
  pop.style.visibility = "visible";
}

function dehighlight_peak(e) {
  $("pop_peak").style.visibility = "hidden";
}

/*
 * hover_logo
 *
 * Activated when the user hovers their cursor over a row in the centrally 
 * enriched motifs table. After a fifth of a second delay, displays a box with 
 * the logo and reverse complement logo.
 */
function hover_logo(e) {
  var popup;
  if (this === logo_row) return;
  logo_row = this;
  if (logo_timer) clearTimeout(logo_timer);
  logo_row.addEventListener('mousemove', move_logo, false);
  popup = $("logo_popup");
  if (popup["data_motif"] != logo_row["data_motif"]) {
    logo_timer = setTimeout(popup_logo, 200);
  } else {
    popup.style.display = "block";
  }
}

/*
 * dehover_logo
 *
 * Activated when the user moves their cursor off a row in the centrally 
 * enriched motifs table. Hides the logo box (or stops it from being displayed).
 */
function dehover_logo(e) {
  var popup = $("logo_popup");
  popup.style.display = "none";
  if (logo_timer) clearTimeout(logo_timer);
  if (logo_row) logo_row.removeEventListener('mousemove', move_logo, false);
  logo_row = null;
  logo_timer = null;
}

/*
 * move_logo
 * 
 * keeps the motif logo at a set distance from the cursor.
 */
function move_logo(e) {
  var popup = $("logo_popup");
  popup.style.left = (e.pageX + 20) + "px";
  popup.style.top = (e.pageY + 20) + "px";
}

/*
 * popup_logo
 *
 * Activated when the user has had the cursor over a row in the centrally 
 * enriched motifs table for longer than 1/5th of a second. It draws the
 * motif logos in a popup and displays the popup.
 */
function popup_logo() {
  if (logo_row == null) return;
  var motif = logo_row["data_motif"];
  var pspm = new Pspm(motif['pwm'], motif['id'], 0, 0, 
      motif['motif_nsites'], motif['motif_evalue']);
  var canvas = $("logo_popup_canvas");
  var logo = logo_1(dna_alphabet, "", pspm);
  draw_logo_on_canvas(logo, canvas, false, 0.5);
  var pspm_rc = pspm.copy().reverse_complement(dna_alphabet);
  var canvas_rc = $("logo_popup_canvas_rc");
  var logo_rc = logo_1(dna_alphabet, "", pspm_rc);
  draw_logo_on_canvas(logo_rc, canvas_rc, false, 0.5);

  var popup = $("logo_popup");
  popup.style.display = "block";
  popup['data_motif'] = motif;
  logo_timer = null;
}

/*
 * swap_colour
 *
 * Activated when the user clicks a swatch in the plotted motifs table.
 * If a swatch has already been selected then swap colours with this one,
 * otherwise record which swatch has been selected.
 */
function swap_colour(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  var row = swatch;
  while (!row['motif']) row = row.parentNode;
  var motif = row['motif'];
  if (swap == null) {
    swatch.appendChild(document.createTextNode("\u21c5"));
    swap = motif;
  } else if (swap == motif) {
    while (swatch.firstChild) swatch.removeChild(swatch.firstChild);
    swap = null;
  } else {
    var swapi = swap['colouri'];
    var motifi = motif['colouri'];
    motif['colouri'] = swapi;
    swap['colouri'] = motifi;
    // swap swatches
    var temp = s_swatches[swapi-1];
    s_swatches[swapi-1] = s_swatches[motifi-1];
    s_swatches[motifi-1] = temp;
    // swap motifs
    temp = s_motifs[swapi-1];
    s_motifs[swapi-1] = s_motifs[motifi-1];
    s_motifs[motifi-1] = temp;
    // swap logos
    temp = s_logos[swapi-1];
    s_logos[swapi-1] = s_logos[motifi-1];
    s_logos[motifi-1] = temp;
    // update swatch colours
    s_swatches[swapi-1].style.backgroundColor = palate[swapi];
    s_swatches[motifi-1].style.backgroundColor = palate[motifi];
    swap = null;
    make_PM_table();
    make_MP_graph();
  }
}

/*
 * set_colour
 *
 * Activated when the user clicks a swatch in the unused colours section.
 * If a swatch has already been selected then set its colour to this one,
 * otherwise warn the user that they must select a motif swatch first.
 */
function set_colour(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  var colouri = swatch['colouri'];
  if (swap) {
    var swapi = swap['colouri'];
    swap['colouri'] = colouri;
    s_swatches[colouri-1] = s_swatches[swapi-1];
    s_motifs[colouri-1] = s_motifs[swapi-1];
    s_logos[colouri-1] = s_logos[swapi-1];
    s_swatches[swapi-1] = null;
    s_motifs[swapi-1] = null;
    s_logos[swapi-1] = null;
    s_swatches[colouri-1].style.backgroundColor = palate[colouri];
    swap = null;
    make_PM_table();
    make_MP_graph();
  } else {
    alert("You must select a motif to set to this colour first.");
  }
}

/*
 * page_loaded
 *
 * Called when the page has loaded for the first time.
 */
function page_loaded() {
  first_load_setup();
  post_load_setup();
}

/*
 * page_loaded
 *
 * Called when a cached page is reshown.
 */
function page_shown(e) {
  if (e.persisted) post_load_setup();
}

/*
 * union_nums
 *
 * Returns a union of two sorted lists of numbers.
 */
function union_nums(list1, list2) {
  "use strict";
  var i, j, list_out;
  i = j = 0;
  list_out = [];
  while (i < list1.length && j < list2.length) {
    if (list1[i] < list2[j]) {
      list_out.push(list1[i]);
      i++;
    } else if (list1[i] === list2[j]) {
      list_out.push(list1[i]);
      i++;
      j++;
    } else { // list1[i] > list2[j]
      list_out.push(list2[j]);
      j++;
    }
  }
  if (i < list1.length) {
    for (; i < list1.length; i++) {
      list_out.push(list1[i]);
    }
  } else {
    for (; j < list2.length; j++) {
      list_out.push(list2[j]);
    }
  }
  return list_out;
}

/*
 * intersect_nums
 *
 * Removes numbers from the target_list which do not also appear in the
 * incoming_list. Both lists must be sorted.
 */
function intersect_nums(target_list, incoming_list) {
  "use strict";
  var i, j, shift;
  shift = i = j = 0;
  while (i < target_list.length && j < incoming_list.length) {
    if (target_list[i] > incoming_list[j]) {
      j++;
    } else if (target_list[i] < incoming_list[j]) {
      i++;
      shift++;
    } else {
      if (shift > 0) target_list[i - shift] = target_list[i];
      i++;
      j++;
    }
  }
  target_list.length = i - shift;
}

function calculate_seq_ids() {
  var i, motif;
  // calculate sequence id sets
  if (!data['options']['noseq']) {
    if (s_count == 0) {
      union_seq_ids = [];
      intersect_seq_ids = [];
    } else {
      for (i = 0; i < s_motifs.length; i++) {
        motif = s_motifs[i];
        if (motif) {
          union_seq_ids = motif["seqs"].slice(0);
          intersect_seq_ids = union_seq_ids.slice(0);
          break;
        }
      }
      for (; i < s_motifs.length; i++) {
        motif = s_motifs[i];
        if (motif === null) continue;
        union_seq_ids = union_nums(union_seq_ids, motif["seqs"]);
        intersect_nums(intersect_seq_ids, motif["seqs"]);
      }
    }
  }
}

function display_seq_ids() {
  var u_n_cont, u_p_cont, i_n_cont, i_p_cont, i_s_cont;
  var union_count, intersect_count, total_count;
  var union_percent, intersect_percent, intersect_seqs, i;
  var sequences;
  sequences = data["sequences"];
  union_count = union_seq_ids.length;
  intersect_count = intersect_seq_ids.length;
  total_count = sequences.length;
  union_percent = Math.round((union_count / total_count) * 100);
  intersect_percent = Math.round((intersect_count / total_count) * 100);
  u_n_cont = $('matching_union_number');
  u_p_cont = $('matching_union_percentage');
  i_n_cont = $('matching_intersection_number');
  i_p_cont = $('matching_intersection_percentage');
  i_s_cont = $('matching_intersection_sequences');
  u_n_cont.innerHTML = "";
  u_n_cont.appendChild(document.createTextNode(union_count));
  u_p_cont.innerHTML = "";
  u_p_cont.appendChild(document.createTextNode(union_percent));
  i_n_cont.innerHTML = "";
  i_n_cont.appendChild(document.createTextNode(intersect_count));
  i_p_cont.innerHTML = "";
  i_p_cont.appendChild(document.createTextNode(intersect_percent));
  intersect_seqs = [];
  for (i = 0; i < intersect_count; i++) {
    intersect_seqs.push(sequences[intersect_seq_ids[i]]);
  }
  i_s_cont.value = intersect_seqs.join("\n");
}

/*
 * find_highest_peaks
 *
 * Locate highest peaks for every motifs
 * Compute every x position and keep the highest one
 */
/*
function find_highest_peaks(smoothing_type) {
  var sequence_length=data['seqlen'];
  var windo=parseInt($("windo").value);
  var half_window = windo / 2;
  var weights = [];
  var tbl = $("motifs");
  var tbody = tbl.tBodies[0];
  if (smoothing_type==1) { // Only computed for weighted moving average
    var total_weight = 0;
    for (var i = 0; i < windo; i++) {
      var pos = i + 0.5;
      var weight = (pos < half_window ? pos / half_window : (windo - pos) / half_window);
      weights.push(weight);
      total_weight += weight;
    }
  }
  for (var i = 0; i < data['motifs'].length; i++) { // For each motif
    var motif = data['motifs'][i];
    var sites = motif['sites'];
    var max_prob=-1;
    var index_max_prob=-1;
    var xpos = (motif.len / 2) - (sequence_length / 2) + half_window;
    var end = sites.length - windo;
    for (var j = 0; j < end; j++, xpos += 1) {
      var sum = 0;
      for (var k = 0; k < windo; k++) {
        sum += (smoothing_type==1) ? sites[j + k] * weights[k] : sites[j + k];
      }
      var avg = (smoothing_type==1) ? sum / total_weight : sum / windo;
      var prob = avg / motif['total_sites'];
      if (prob>max_prob) { // If Y axis value is higher than saved one
        max_prob=prob; // Save it
        index_max_prob=Math.floor(xpos); // Save the location
      }
    }
    motif["highest_peak"]=index_max_prob; // Save highest peak location for this motif
  }
}*/

/*
 * first_load_setup
 *
 * Setup state that is dependant on everything having been loaded already.
 * On browsers which cache state this is only run once.
 */
function first_load_setup() {
  if (data['options']['noseq']) {
    // no sequence ids to display
    $('seq_area').style.display='none';
  }
  if (!data['options']['local']) {
    // bins are centered, there is only one peak
    $('show_blocation').checked = false;
    $('CB_show_blocation').style.display='none';
    $('box_peak_sort').style.display = 'none';
    toggle_class($('motifs'), 'hide_OEbins', true);
  }
  if (!data['options']['neg_sequences']) {
    // no negative sites, so hide negative bin sites and total
    $('CB_show_negbsites').style.display= 'none';
    $('CB_show_negtsites').style.display= 'none';
  }
  if (!data['options']['disc']) {
    // negative data set was not used with a discriminative search
    $('CB_show_negative_binomial').style.display='none';
    $('CB_filter_on_negbintest').style.display='none';
  }
  if (!data['options']['mcc']) {
    $('CB_show_MCC').style.display='none';
  }
  if (!data['options']['optimize_score']) {
    // per motif score optimisation turned off, so hide column
    $('show_score').checked = false;
  }
  // rebrand centrimo
  $('title_img').alt = data['program'];
  document.title = data['program'];
}

/*
 * post_load_setup
 *
 * Setup state that is dependant on everything having been loaded already.
 */
function post_load_setup() {
  "use strict";
  var tbl, i;
  $("filter_id").disabled = !($("filter_on_id").checked);
  $("filter_alt").disabled = !($("filter_on_alt").checked);
  $("filter_evalue").disabled = !($("filter_on_evalue").checked);
  $("filter_binwidth").disabled = !($("filter_on_binwidth").checked);
  $("filter_negbintest").disabled = !($("filter_on_negbintest").checked);
  tbl = $("motifs");
  toggle_class(tbl, "hide_db", !$("show_db").checked);
  toggle_class(tbl, "hide_id", !$("show_id").checked);
  toggle_class(tbl, "hide_name", !$("show_name").checked);
  toggle_class(tbl, "hide_evalue", !$("show_evalue").checked);
  toggle_class(tbl, "hide_pvalue", !$("show_pvalue").checked);
  toggle_class(tbl, "hide_MCC", !$("show_MCC").checked);
  toggle_class(tbl, "hide_blocation", !$("show_blocation").checked);
  toggle_class(tbl, "hide_bwidth", !$("show_bwidth").checked);
  toggle_class(tbl, "hide_bsites", !$("show_bsites").checked);
  toggle_class(tbl, "hide_tsites", !$("show_tsites").checked);
  toggle_class(tbl, "hide_negbsites", !$("show_negbsites").checked);
  toggle_class(tbl, "hide_negtsites", !$("show_negtsites").checked);
  toggle_class(tbl, "hide_negative_binomial", !$("show_negative_binomial").checked);
  toggle_class(tbl, "hide_maxprob", !$("show_maxprob").checked);
  toggle_class(tbl, "hide_hpeak", !$("show_hpeak").checked); //max prob location
  toggle_class(tbl, "hide_nbinstested", !$("show_nbinstested").checked);
  toggle_class(tbl, "hide_score", !$("show_score").checked);
  make_PM_table();
  make_CEM_table();
  make_MP_graph();
  if (!data['options']['noseq']) display_seq_ids();
}

/*
 *  sort_motif_id
 *
 *  Takes 2 motif objects and compares them based on id and database.
 */
function sort_motif_id(m1, m2) {
  var diff;
  diff = m1['id'].localeCompare(m2['id']);
  if (diff == 0) {
    diff = m1['db'] - m2['db'];
  }
  return diff;
}

/*
 * sort_motif_alt
 *
 * Takes 2 motif objects and compares them based on alternate id.
 */
function sort_motif_alt(m1, m2) {
  var diff;
  if (m1['alt'] && m2['alt']) {
    diff = m1['alt'].localeCompare(m2['alt']);
    if (diff != 0) return diff;
    return sort_motif_evalue(m1, m2);
  } else {
    if (m1['alt']) {
      return -1;
    } else {
      return 1;
    }
  }
}

/*
 * sort_motif_evalue
 *
 * Takes 2 motif objects and compares them based on the log_adj_pvalue.
 */
function sort_motif_evalue(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  return sort_motif_id(m1, m2);
}

/*
 * sort_motif_spread
 *
 * Takes 2 motif objects and compares them based on the bin_width.
 */
function sort_motif_spread(m1, m2) {
  var diff, p2, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  return sort_motif_id(m1, m2);
}

/*
 * sort_motif_probability
 *
 * Takes 2 motif objects and compares them based on the maximum probability.
 */
function sort_motif_probability(m1, m2) {
  var diff;
  diff = 0; //FIXME //m2['max_prob'] - m1['max_prob'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_sites
 *
 * Takes 2 motif objects and compares them based on the bin sites.
 */
function sort_motif_sites(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['sites'] - p2['sites'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_center
 *
 * Takes 2 motif objects and compares them based on the bin location.
 */
function sort_motif_center(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['center'] - p2['center'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_mcc
 *
 * Takes 2 motif objects and compares them based on the Matthews Correlation Coefficient.
 */
function sort_motif_mcc(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p2['mcc'] - p1['mcc'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_total_sites
 *
 * Takes 2 motif objects and compares them based on the total sites.
 */
function sort_motif_total_sites(m1, m2) {
  var diff;
  diff = m2['total_sites'] - m1['total_sites'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}


/*
 * get_sort_cmp
 *
 * Gets the sorting comparator by index.
 *
 */
function motif_sort_cmp(index) {
  "use strict";
  switch (index) {
    case 0:
      return sort_motif_id;
    case 1:
      return sort_motif_alt;
    case 2:
      return sort_motif_evalue;
    case 3:
      return sort_motif_mcc;
    case 4:
      return sort_motif_center;
    case 5:
      return sort_motif_spread;
    case 6:
      return sort_motif_sites;
    case 7:
      return sort_motif_total_sites;
    case 8:
      return sort_motif_probability;
    default:
      return sort_motif_evalue;
  }
}

function sort_peak_evalue(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  return p1['center'] - p2['center']; 
}

function sort_peak_mcc(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p2['mcc'] - p1['mcc'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_center(p1, p2) {
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  return p1['center'] - p2['center']; 
}

function sort_peak_spread(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  return p1['center'] - p2['center']; 
}

function sort_peak_sites(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['sites'] - p2['sites'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_neg_pvalue(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  // sort largest to smallest as we want peaks that aren't
  // enriched in the negative set
  diff = p2['neg_log_adj_pvalue'] - p2['neg_log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p2['neg_sites'] - p1['neg_sites'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_neg_sites(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p2['neg_sites'] - p1['neg_sites'];
  if (diff != 0) return diff;
  diff = p2['neg_log_adj_pvalue'] - p2['neg_log_adj_pvalue'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function peak_sort_cmp(index) {
  "use strict";
  switch (index) {
    case 0:
      return sort_peak_evalue;
    case 1:
      return sort_peak_mcc;
    case 2:
      return sort_peak_center;
    case 3:
      return sort_peak_spread;
    case 4:
      return sort_peak_sites;
    case 5:
      return sort_peak_neg_pvalue;
    case 6:
      return sort_peak_neg_sites;
    default:
      return sort_peak_evalue;
  }
}

/*
 * log2str
 *
 * Converts a log value into scientific notation.
 */
function log2str(log_val, precision) {
  var log10_val, e, m;
  if (log_val < 0) {
    log10_val = log_val / Math.log(10);
    e = Math.floor(log10_val);
    m = Math.pow(10, log10_val - e);
    if (m + (0.5 * Math.pow(10, -precision)) >= 10) {
      m = 1;
      e += 1;
    }
    return "" + m.toFixed(precision) + "e" + e;
  } else {
    return Math.exp(log_val).toFixed(precision);
  }
}

/*
 * str2log
 *
 * Converts a scientific notation number string to a log value.
 */
function str2log(str, default_value) {
  var sci_num_re, parts, m, e, log_num;
  if (typeof default_value === "undefined") {
    default_value = null;
  }
  sci_num_re = /^([+]?\d+(?:\.\d+)?)(?:[eE]([+-]\d+))?$/;
  parts = sci_num_re.exec(str);
  if (parts && parseFloat(parts[1]) != 0) {
    m = parseFloat(parts[1]);
    if (m === 0) return default_value;
    e = (parts.length == 3 && parts[2] != null ? parseInt(parts[2]) : 0);
    log_num = (((Math.log(m)/Math.log(10)) + e) * Math.log(10));
    return log_num;
  } else {
    return default_value;
  }
}

/*
 * pvstr
 *
 * Gets the p-value of the motif in string form.
 */
function pvstr(peak) {
  return log2str(peak['log_adj_pvalue'], 1);
}

/*
 * evstr
 *
 * Gets the E-value of the motif in string form.
 */
function evstr(peak) {
  return log2str(peak['log_adj_pvalue'] + Math.log(data['tested']), 1);
}

/*
 *  make_link
 *
 *  Creates a text node and if a URL is specified it surrounds it with a link. 
 *  If the URL doesn't begin with "http://" it automatically adds it, as 
 *  relative links don't make much sense in this context.
 */
function make_link(text, url) {
  var textNode = null;
  var link = null;
  if (typeof text !== "undefined" && text !== null) textNode = document.createTextNode(text);
  if (typeof url === "string") {
    if (url.indexOf("//") == -1) {
      url = "http://" + url;
    }
    link = document.createElement('a');
    link.href = url;
    if (textNode) link.appendChild(textNode);
    return link;
  } 
  return textNode;
}

/*
 * make_swatch
 *
 * Make a swatch block.
 */
function make_swatch(colouri) {
  var swatch = document.createElement('div');
  swatch.className = 'swatch';
  swatch.style.backgroundColor = palate[colouri];
  swatch.style.color = text_palate[colouri];
  return swatch;
}

function make_CEM_main_row(tbody, motif) {
  "use strict";
  var colouri, row, swatch, peak, expander;
  peak = motif['peaks'][0];
  colouri = motif['colouri'];
  if (!colouri) colouri = 0;
  row = tbody.insertRow(tbody.rows.length);
  row['data_peak'] = peak;
  swatch = make_swatch(colouri);
  swatch.onclick = toggle_graph_motif;
  if (colouri != 0) {
    s_swatches[colouri -1] = swatch;
  }
  add_cell(row, swatch);
  add_text_cell(row, motif_dbs[motif['db']]['name'], 'col_db');
  add_cell(row, make_link(motif['id'], motif['url']), 'col_id');
  add_text_cell(row, motif['alt'], "col_name");
  add_text_cell(row, evstr(peak), 'col_evalue');
  add_text_cell(row, pvstr(peak), 'col_pvalue');
  if (data['options']['mcc']) {
    add_text_cell(row, peak['mcc'].toFixed(3), "col_MCC");
  } else {
    add_text_cell(row, '', "col_MCC");
  }
  add_text_cell(row, peak['center'], "col_blocation");
  add_text_cell(row, peak['spread'], 'col_bwidth');
  add_text_cell(row, Math.round(peak['sites']), "col_bsites");
  add_text_cell(row, motif['total_sites'], "col_tsites");
  if (data['options']['neg_sequences']) {
    add_text_cell(row, Math.round(peak['neg_sites']), "col_negbsites");
    add_text_cell(row, motif['neg_total_sites'], "col_negtsites");
  } else {
    add_text_cell(row, '', "col_negbsites")
    add_text_cell(row, '', "col_negtsites");
  }
  if (data['options']['disc']) {
    add_text_cell(row, log2str(peak['neg_log_adj_pvalue'],1), "col_negative_binomial");
  } else {
    add_text_cell(row, '', "col_negative_binomial");
  }
  add_text_cell(row, motif["max_prob"].toFixed(4), "col_maxprob");
  add_text_cell(row, motif["max_prob_loc"], "col_problocation");
  add_text_cell(row, motif['n_tested'], "col_nbinstested");
  add_text_cell(row, motif['score_threshold'].toFixed(2), "col_score");
  if (motif['peaks'].length > 1) {
    expander = document.createElement('span');
    expander.appendChild(document.createTextNode("\u21A7"));
    expander.className = "expander";
    expander.addEventListener("click", toggle_peaks, false);
    add_cell(row, expander, "col_OEbins");
  } else {
    add_text_cell(row, '-', "col_OEbins");
  }
  row.addEventListener('mouseover', highlight_peak, false);
  row.addEventListener('mouseout', dehighlight_peak, false);
}

function make_CEM_sub_row(tbody, peak) {
  var row = tbody.insertRow(tbody.rows.length);
  row['data_peak'] = peak;
  row.className = "sub_peak";
  add_text_cell(row,'\u2022', 'no_swatch');
  add_text_cell(row, '', 'col_db');
  add_text_cell(row, '', 'col_id');
  add_text_cell(row, '', 'col_name');
  add_text_cell(row, evstr(peak), 'col_evalue');
  add_text_cell(row, pvstr(peak), 'col_pvalue');
  if (data['options']['mcc']) {
    add_text_cell(row, peak['mcc'].toFixed(3), "col_MCC");
  } else {
    add_text_cell(row, '', "col_MCC");
  }
  add_text_cell(row, peak['center'], "col_blocation");
  add_text_cell(row, peak['spread'], 'col_bwidth');
  add_text_cell(row, Math.round(peak['sites']), "col_bsites");
  add_text_cell(row, '', "col_tsites");
  if (data['options']['neg_sequences']) {
    add_text_cell(row, Math.round(peak['neg_sites']), "col_negbsites");
  } else {
    add_text_cell(row, '', "col_negbsites")
  }
  add_text_cell(row, '', "col_negtsites");
  if (data['options']['disc']) {
    add_text_cell(row, log2str(peak['neg_log_adj_pvalue'],1), "col_negative_binomial");
  } else {
    add_text_cell(row, '', "col_negative_binomial");
  }
  add_text_cell(row, '', "col_maxprob");
  add_text_cell(row, '', "col_problocation");
  add_text_cell(row, '', "col_nbinstested");
  add_text_cell(row, '', "col_score");
  add_text_cell(row, '', "col_OEbins");
  row.addEventListener('mouseover', highlight_peak, false);
  row.addEventListener('mouseout', dehighlight_peak, false);
}

function make_CEM_skip_row(tbody, n_skipped) {
  var row, cell, desc;
  if (n_skipped === 0) return;
  row = tbody.insertRow(tbody.rows.length);
  row.className = "sub_peak";

  if (n_skipped === 1) {
    desc = "1 peak hidden due to filters";
  } else {
    desc = n_skipped + " peaks hidden due to filters";
  }

  cell = row.insertCell(row.cells.length);
  cell.colSpan = 19;
  cell.style.textAlign = "center";
  cell.style.fontWeight = "bold";
  cell.appendChild(document.createTextNode(desc));
}

/*
 * make_CEM_table
 *
 * Generate the table which lists centrally enriched motifs.
 */
function make_CEM_table() {
  var motif_sort, peak_sort;
  var filter, motifs, filtered, motif, peaks, motif_dbs;
  var tbl, tbody, row, cell, i, j, skipped;
  // get the filter and sort comparator
  motif_sort = motif_sort_cmp(parseInt($('motif_sort').value));
  peak_sort = peak_sort_cmp(parseInt($('peak_sort').value));
  filter = get_filter();

  motifs = data['motifs'];
  // sort the motif peaks
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    peaks = motif['peaks'];
    for (j = 0; j < peaks.length; j++) {
      peaks[j]["filtered"] = filter_peak(filter, peaks[j]);
    }
    peaks.sort(peak_sort);
  }
  // filter the motifs
  filtered = [];
  for (i = 0; i < motifs.length; i++) {
    if (filter_motif(filter, motifs[i])) continue;
    if (motifs[i]["peaks"][0]["filtered"]) continue;
    filtered.push(motifs[i]);
  }
  // sort
  filtered.sort(motif_sort);
  // limit
  if (filter["on_count"]) {
    if (filtered.length > filter["count"]) filtered.length = filter["count"];
  }
  // re-add any omitted s_motifs motifs
  outer_loop:
  for (i = 0; i < s_motifs.length; i++) {
    if (s_motifs[i] == null) continue;
    for (j =0; j < filtered.length; j++) {
      if (filtered[j]['id'] === s_motifs[i]['id']) {
        continue outer_loop;
      }
    }
    filtered.push(s_motifs[i]);
  }
  // sort again
  filtered.sort(motif_sort);

  // clear the table
  tbl = $("motifs");
  for (i = tbl.tBodies.length - 1; i >= 0; i--) {
    tbody = tbl.tBodies[i];
    tbody.parentNode.removeChild(tbody);
  }

  motif_dbs = data['motif_dbs'];
  // add the new rows to the table
  for (i = 0; i < filtered.length; i++) {
    motif = filtered[i];
    peaks = motif['peaks'];
    tbody = document.createElement('tbody');
    tbody.className = "peak_group";
    tbody["data_motif"] = motif;
    tbody.addEventListener('mouseover', hover_logo, false);
    tbody.addEventListener('mouseout', dehover_logo, false);
    make_CEM_main_row(tbody, motif);
    skipped = 0;
    for (j = 1; j < peaks.length; j++) {
      if (filter_peak(filter, peaks[j])) {
        skipped++;
        continue;
      }
      make_CEM_sub_row(tbody, peaks[j]);
    }
    make_CEM_skip_row(tbody, skipped);
    tbl.appendChild(tbody);
  }
  // note the count of filtered motifs
  if (filtered.length != motifs.length) {
    skipped =  motifs.length - filtered.length;
    tbody = document.createElement('tbody');
    row = tbody.insertRow(tbody.rows.length);

    if (skipped === 1) {
      desc = "1 motif hidden due to filters";
    } else {
      desc = skipped + " motifs hidden due to filters";
    }
    cell = row.insertCell(row.cells.length);
    cell.colSpan = 19;
    cell.style.textAlign = "center";
    cell.style.fontWeight = "bold";
    cell.appendChild(document.createTextNode(desc));
    tbl.appendChild(tbody);
  }
}

function get_filter() {
  var filter, id_pat, alt_pat, alt_re, log_evalue_max, spread, count;
  var neg_log_pvalue_min;
  filter = {};
  // get the db filter
  filter["on_db"] = $("filter_on_db").checked;
  filter["db"] = $("filter_db").value;
  // get the id filter
  filter["on_id"] = $("filter_on_id").checked;
  id_pat = $("filter_id").value;
  try {
    filter["id"] = new RegExp(id_pat);
    $("filter_id").className = "";
  } catch (err) {
    $("filter_id").className = "error";
    filter["on_id"] = false;
  }
  // get the name filter
  filter["on_alt"] = $("filter_on_alt").checked;
  alt_pat = $("filter_alt").value;
  try {
    filter["alt"] = new RegExp(alt_pat);
    $("filter_alt").className = "";
  } catch (err) {
    filter["on_alt"] = false;
    $("filter_alt").className = "error";
  }
  // get the evalue filter
  filter["on_pvalue"] = $("filter_on_evalue").checked;
  if ((log_evalue_max = str2log($("filter_evalue").value)) != null) {
    filter["log_pvalue"] = log_evalue_max - Math.log(data['tested']);
    $("filter_evalue").className = "";
  } else {
    filter["on_pvalue"] = false;
    $("filter_evalue").className = "error";
  }
  // get the spread filter
  filter["on_spread"] = $("filter_on_binwidth").checked;
  spread = parseInt($("filter_binwidth").value);
  if (isNaN(spread) || spread < 1) {
    filter["on_spread"] = false;
    $("filter_binwidth").className = "error";
  } else {
    filter["spread"] = spread;
    $("filter_binwidth").className = "";
  }
  // get the negative binomial test filter
  filter["on_neg"] = data['options']['disc'] && $("filter_on_negbintest").checked;
  if ((neg_log_pvalue_min = str2log($("filter_negbintest").value)) != null) {
    $("filter_negbintest").className = "";
    filter["neg_log_pvalue"] = neg_log_pvalue_min;
  } else {
    filter["on_neg"] = false;
    $("filter_negbintest").className = "error";
  }
  // get the motif count limit
  filter["on_count"] = $("filter_on_top").checked;
  count = parseInt($("filter_top").value);
  if (isNaN(count) || count < 1) {
    filter["on_count"] = false;
    $("filter_top").className = "error";
  } else {
    filter["count"] = count;
    $("filter_top").className = "";
  }
  return filter; 
}

function filter_motif(filter, motif) {
  if (filter["on_db"] && motif["db"] != filter["db"]) return true;
  if (filter["on_id"] && !filter["id"].test(motif["id"])) return true;
  if (filter["on_alt"] && !filter["alt"].test(motif["alt"])) return true;
  return false;
}

function filter_peak(filter, peak) {
  if (filter["on_pvalue"] && peak["log_adj_pvalue"] > filter["log_pvalue"]) return true;
  if (filter["on_spread"] && peak["spread"] > filter["spread"]) return true;
  if (filter["on_neg"] && peak["neg_log_adj_pvalue"] < filter["neg_log_pvalue"]) return true;
  return false;
}

function filter_CEM_table() {
  "use strict";
  var tbl, tbody, tr, motif, peaks, i, j, filter;
  tbl = $("motifs");
  filter = get_filter();
  for (i = 0; i < tbl.tBodies.length; i++) {
    tbody = tbl.tBodies[i];
    motif = tbody["data_motif"];
    toggle_class(tbody, "filtered", filter_motif(filter, motif));
    for (j = 0; j < tbody.rows.length; j++) {

    }
  }
}

/*
 * show_all_peaks
 *
 * Show or hide sub-peaks
 */
function show_all_peaks(param) {
  var tbl = $("motifs");
  var tbody = tbl.tBodies[0];
  var NValue=param.childNodes[0].nodeValue; // Catch the motif (based on argument value sent by clicking on arrow)
  var bin_number=0;
  for (var i=0; i<tbody.rows.length;i++) { // For each motif
    if (tbody.rows[i].className==param.className) {    // For each sub-peaks
      bin_number++;
      if (must_be_display(param.className,bin_number)==false || NValue=="\u21A5") { // If it has to be hiden or arrow was up
        tbody.rows[i].style.display="none";    // Hide it
      }
      else {
      tbody.rows[i].style.display="table-row";    // Show it
      }
    }
  }
  param.childNodes[0].nodeValue= (NValue=="\u21A7") ? "\u21A5" : "\u21A7" ; // Change arrow orientation
}

function toggle_peaks(e) {
  var expander, group;
  if (!e) e = window.event;
  if (e.target) expander = e.target;
  else if (e.srcElement) expander = e.srcElement;
  group = find_parent(expander.parentNode, "peak_group");
  toggle_class(group, "more");
}

/*
 * must_be_display
 *
 * Check all sub-peaks and verify if they have to be displayed or not (based on filters)
 */
function must_be_display(ID, bin_number) {
  "use strict";
  var motifs, i, motif, peak, log_pvalue_max, log_evalue_max;
  motifs = data['motifs'];
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    if (motif['db'] + motif['id'] == ID) {    // Catch the motif
      peak = motif['peaks'][bin_number];    // Catch the sub-peaks
      if ($("filter_on_evalue").checked) {
        if ((log_evalue_max = str2log($("filter_evalue").value)) != null) {
          log_pvalue_max = log_evalue_max - Math.log(data['tested']);
        } else {
          log_pvalue_max = 0;
        }
        if (log_pvalue_max < peak['log_adj_pvalue']) return false; 
      }
      if ($("filter_on_binwidth").checked && 
          parseInt($("filter_binwidth").value) > peak['spread']) {
            return false;
      }
    }
  }
  return true;
}

/*
 * make_PM_table
 *
 * Generate the table which lists plotted motifs
 */
function make_PM_table() {
  swap = null;
  var graphed = [];
  var unused = [];
  for (var i = 1; i < palate.length; i++) {
    if (s_motifs[i-1]) graphed.push(s_motifs[i-1]);
    else unused.push(i);
  }
  graphed.sort(sort_motif_evalue);

  var tbl = $("graph_list");
  var tbody = tbl.tBodies[0];
  while (tbody.rows.length > 0) {
    tbody.deleteRow(0);
  }
  // add the new rows to the table
  for (var i = 0; i < graphed.length; i++) {
    var motif = graphed[i];
    var colouri = motif['colouri'];
    if (!colouri) colouri = 0;
    var row = tbody.insertRow(tbody.rows.length);
    row['motif'] = motif;
    var swatch = make_swatch(colouri);
    swatch.onmousedown = swap_colour;
    add_cell(row, swatch);
    add_cell(row, make_link(motif['id'], motif['url']));
    if (!s_logos[colouri-1]) {
      s_logos[colouri-1] = document.createElement("canvas");
      var pspm = new Pspm(motif['pwm'], motif['id'], 0, 0, 
          motif['motif_nsites'], motif['motif_evalue']);
      var logo = logo_1(dna_alphabet, "", pspm);
      draw_logo_on_canvas(logo, s_logos[colouri-1], false, 0.3);
    }
    add_cell(row, s_logos[colouri-1]);
  }
  var div = $("unused_colours");
  while (div.firstChild) div.removeChild(div.firstChild);
  $("unused_colours_section").style.display = (unused.length > 0 ? "block" : "none");
  for (var i = 0; i < unused.length; i++) {
    var swatch = make_swatch(unused[i]);
    swatch['colouri'] = unused[i];
    swatch.onclick = set_colour;
    div.appendChild(swatch);
  }
}

/*
 * make_MP_graph
 *
 * Create a motif probability graph on the canvas.
 */
function make_MP_graph() {
  var canvas = $("graph");
  canvas.width = canvas.width;
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');
    make_MP_graph2(ctx, canvas.width, canvas.height);
  }
}

function download_eps() {
  var canvas = $("graph");
  canvas.width = canvas.width;
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');
    var eps_ctx = new EpsContext(ctx, canvas.width, canvas.height);
    eps_ctx.register_font("14pt Helvetica", "Helvetica", 14 / 3 * 4);
    eps_ctx.register_font("16px Helvetica", "Helvetica", 16);
    eps_ctx.register_font("9px Helvetica", "Helvetica", 9);
    make_MP_graph2(ctx, canvas.width, canvas.height);
    $("eps_content").value = eps_ctx.eps();
  }
}

function make_MP_graph2(ctx, width, height) {
  "use strict";
  var windo, type, legend, motifs, rset, i, motif;
  var name, sig, colour, weights, graph, peak_highlight;
  // get the graph settings
  windo = parseInt($("windo").value);
  if (isNaN(windo) || windo < 1) {
    windo = 20;
    $("windo").value = 20;
  }
  type = parseInt($("plot_type").value);
  legend = parseInt($("legend").value);
  // get the selected motifs
  motifs = [];
  for (i = 0; i < s_motifs.length; i++) {
    if (s_motifs[i] != null) motifs.push(s_motifs[i]);
  }
  // sort the motifs
  motifs.sort(sort_motif_evalue);
  // create a result set with all the selected motifs
  rset = new CentrimoRSet(data["seqlen"]);
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    name = motif["id"];
    if (motif["alt"]) name = motif["alt"] + " " + motif["id"];
    sig = "p=" + log2str(motif["best_log_adj_pvalue"], 1);
    colour = palate[motif["colouri"]];
    rset.add(name, sig, colour, motif["len"], motif["total_sites"],
        motif["sites"], motif["neg_total_sites"], motif["neg_sites"]);
  }
  // get the smoothing weights
  weights = (type == 1 ? triangular_weights(windo) : uniform_weights(windo));
  // now make a new graph from the result set and smoothing weights
  graph = new CentrimoGraph(rset, weights, "CentriMo " + data["version"]);
  graph_metrics = graph.draw_graph(ctx, width, height, legend, legend_x, legend_y);
  peak_highlight = $("pop_peak");
  peak_highlight.style.top = graph_metrics.top_edge + "px";
  peak_highlight.style.height = (graph_metrics.bottom_edge - graph_metrics.top_edge) + "px";
}


    </script>
    <style type="text/css">
div.graph_box {
  position: relative;
}
div.pop_graph_peak {
  position:absolute; 
  left: 0;
  top: 0; 
  z-index: 5; 
  width: 10px;
  height: 10px; 
  opacity: 0.2; 
  background-color: #3333ff;
  visibility: hidden;
}
table.inputs {
  margin-top: 20px;
  border-collapse:collapse;
}
table.inputs * td, table.inputs * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.motifs {
  margin-top: 20px;
  border-collapse:collapse;
}
table.motifs * td, table.motifs * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.motifs * td.col_blocation, table.motifs * td.col_bwidth, 
table.motifs * td.col_bsites, table.motifs * td.col_tsites,
table.motifs * td.col_maxprob, table.motifs * td.col_problocation,
table.motifs * td.col_nbinstested, table.motifs * td.col_score {
  text-align: right;
  padding-right: 40px;
}
table.motifs tbody:hover { 
  background: #ddddff; 
}
table.motifs tbody tr:hover {
  background: #ccccff; 
}
table.hide_db .col_db {
  display: none;
}
table.hide_id .col_id {
  display: none;
}
table.hide_name .col_name {
  display: none;
}
table.hide_evalue .col_evalue {
  display: none;
}
table.hide_pvalue .col_pvalue {
  display: none;
}
table.hide_MCC .col_MCC {
  display: none;
}
table.hide_maxprob .col_maxprob {
  display: none;
}
table.hide_bsites .col_bsites {
  display: none;
}
table.hide_negbsites .col_negbsites {
  display: none;
}
table.hide_blocation .col_blocation {
  display: none;
}
table.hide_hpeak .col_problocation {
  display: none;
}
table.hide_bwidth .col_bwidth {
  display: none;
}
table.hide_tsites .col_tsites {
  display: none;
}
table.hide_negtsites .col_negtsites {
  display: none;
}
table.hide_nbinstested .col_nbinstested {
  display: none;
}
table.hide_score .col_score {
  display: none;
}
table.hide_negative_binomial .col_negative_binomial {
  display: none;
}
table.hide_OEbins .col_OEbins {
  display: none;
}
div.graph_options_section {
  width:30%; 
  float:right;
}
div.graph_options_section h5 {
  margin-top: 10px;
}
table.graph_list {
  border-collapse:collapse;
}
table.graph_list * td, table.graph_list * th {
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 1px;
  padding-bottom: 1px;
}
th.deselect {
  font-size:25px; 
  cursor: default;
}
th.deselect:hover {
  color: red;
}
div.filter {
  display: inline-block;
  padding-right: 10px;
}
div.swatch {
  margin: auto;
  width: 20px;
  height: 20px;
  text-align: center;
  font-size: 16px;
  border: 1px solid black;
  cursor: default;
}
div.swatch:hover {
  width: 16px;
  height: 16px;
  font-size: 16px;
  border: 3px outset black;
}
div.swatch:active {
  width: 16px;
  height: 16px;
  font-size: 16px;
  border: 3px inset black;
}
span.expander {
  cursor: pointer;
  font-size: larger;
}
div.pop_logo {
  position:absolute;
  z-index:1;
  top:0px;
  left:0px;
  border: 3px outset black;
  background-color: white;
  display:none;
}
div.pop_colour {
  position:absolute;
  z-index:1;
  top:0px;
  left:0px;
  margin-left: -13px;
  margin-top: -13px;
  display:none;

}
div.pop_content {
  position:absolute;
  z-index:1;
  width:300px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}

span.arrow {
  font-size: larger;
  color: red;
}

#unused_colours div.swatch {
  display: inline-block;
  margin-right: 5px;
}

.no_swatch {
  text-align: center;
  font-size: larger;
}

input.error:enabled {
  background: #FF5555;
}

tr.sub_peak {
  display: none;
}

tbody.more > tr.sub_peak {
  display: table-row;
}

    </style>
    <style type="text/css">
        /* The following is the content of meme.css */
        body { background-color:white; font-size: 12px; font-family: Verdana, Arial, Helvetica, sans-serif;}

        div.help {
          display: inline-block;
          margin: 0px;
          padding: 0px;
          width: 12px;
          height: 13px;
          cursor: pointer;
          background-image: url("help.gif");
          background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAANAQMAAACn5x0BAAAAAXNSR0IArs4c6QAAAAZQTFRFAAAAnp6eqp814gAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH2gMJBQgGYqhNZQAAACZJREFUCNdj+P+BoUGAoV+AYeYEEGoWYGgTYGgRAAm2gRGQ8f8DAOnhC2lYnqs6AAAAAElFTkSuQmCC");
        }

        div.help2 {
          color: #999;
          display: inline-block;
          width: 12px;
          height: 12px;
          border: 1px solid #999;
          font-size: 13px;
          line-height:12px;
          font-family: Helvetica, sans-serif;
          font-weight: bold;
          font-style: normal;
          cursor: pointer;
        }
        div.help2:hover {
          color: #000;
          border-color: #000;
        }
        
        p.spaced { line-height: 1.8em;}
        
        span.citation { font-family: "Book Antiqua", "Palatino Linotype", serif; color: #004a4d;}

        p.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

        td.jump { font-size: 13px; color: #ffffff; background-color: #00666a;
          font-family: Georgia, "Times New Roman", Times, serif;}

        a.jump { margin: 15px 0 0; font-style: normal; font-variant: small-caps;
          font-weight: bolder; font-family: Georgia, "Times New Roman", Times, serif;}

        h2.mainh {font-size: 1.5em; font-style: normal; margin: 15px 0 0;
          font-variant: small-caps; font-family: Georgia, "Times New Roman", Times, serif;}

        h2.line {border-bottom: 1px solid #CCCCCC; font-size: 1.5em; font-style: normal;
          margin: 15px 0 0; padding-bottom: 3px; font-variant: small-caps;
          font-family: Georgia, "Times New Roman", Times, serif;}

        h4 {border-bottom: 1px solid #CCCCCC; font-size: 1.2em; font-style: normal;
          margin: 10px 0 0; padding-bottom: 3px; font-family: Georgia, "Times New Roman", Times, serif;}

        h5 {margin: 0px}

        a.help { font-size: 9px; font-style: normal; text-transform: uppercase;
          font-family: Georgia, "Times New Roman", Times, serif;}

        div.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}
        
        div.pad1 { margin: 10px 5px;}

        div.pad2 { margin: 25px 5px 5px;}
        h2.pad2 { padding: 25px 5px 5px;}

        div.pad3 { padding: 5px 0px 10px 30px;}

        div.box { border: 2px solid #CCCCCC; padding:10px;}

        div.bar { border-left: 7px solid #00666a; padding:5px; margin-top:25px; }

        div.subsection {margin:25px 0px;}

        img {border:0px none;}

        th.majorth {text-align:left;}
        th.minorth {font-weight:normal; text-align:left; width:8em; padding: 3px 0px;}
        th.actionth {font-weight:normal; text-align:left;}

        .strand_name {text-align:left;}
        .strand_side {padding:0px 10px;}
        .strand_start {padding:0px 10px;}
        .strand_pvalue {text-align:center; padding:0px 10px;}
        .strand_lflank {text-align:right; padding-right:5px; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace; color:gray;}
        .strand_seq {text-align:center; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace;}
        .strand_rflank {text-align:left; padding-left:5px; font-weight:bold; font-size:large; font-family: 'Courier New', Courier, monospace; color:gray;}

        .block_td {height:25px;}
        .block_container {position:relative; width:98%; height:25px; padding:0px; margin: 0px 0px 0px 1em;}
        .block_motif {position:absolute; z-index:3; height:12px; top:0px; text-align:center; vertical-align:middle; background-color:cyan;}
        .block_rule {position:absolute; z-index:2; width:100%; height:1px; top:12px; left:0px; background-color:gray;}
        .block_plus_sym {position:absolute; z-index:4; line-height:12px; top:0px; left:-1em;}
        .block_minus_sym {position:absolute; z-index:4; line-height:12px; top:13px; left:-1em;}

        .tic_major {position:absolute; border-left:2px solid blue; height:0.5em; top:0em;}
        .tic_minor {position:absolute; border-left:1px solid blue; height:0.2em; top:0em;}
        .tic_label {position:absolute; top:0.5em;  height: 1em; text-align:center; vertical-align:middle}

        .explain h5 {font-size:1em; margin-left: 1em;}

        div.doc {margin-left: 2em; margin-bottom: 3em;}
        
        div.tabArea {
          font-size: 80%;
          font-weight: bold;
        }

        a.tab {
          background-color: #ddddff;
          border: 1px solid #000000;
          padding: 2px 1em 2px 1em;
          text-decoration: none;
        }
        div.tabArea.base a.tab {
          border-top-width: 0px;
        }
        div.tabArea.top a.tab {
          border-bottom-width: 0px;
        }

        a.tab, a.tab:visited {
          color: #808080;
        }

        a.tab:hover {
          background-color: #d0d0d0;
          color: #606060;
        }
        a.tab.activeTab, a.tab.activeTab:hover, a.tab.activeTab:visited {
          background-color: #f0f0f0;
          color: #000000;
        }
        div.tabMain {
          border: 1px solid #000000;
          background-color: #ffffff;
          padding: 5px;
          margin-right: 5px;
        }
        th.trainingset {
          border-bottom: thin dashed black; 
          font-weight:normal; 
          padding:0px 10px;
        }
        .dnaseq {
          font-weight: bold; 
          font-size: large; 
          font-family: 'Courier New', Courier, monospace;
        }
        .dna_A {
          color: rgb(204,0,0);
        }
        .dna_C {
          color: rgb(0,0,204);
        }
        .dna_G {
          color: rgb(255,179,0);
        }
        .dna_T {
          color: rgb(0,128,0);
        }

    </style>
  </head>
  <body onload="page_loaded()" onpageshow="page_shown(event)">
    <!-- Popups -->
    <div id="logo_popup" class="pop_logo">
      <canvas id="logo_popup_canvas" width="200" height="50"></canvas>
      <canvas id="logo_popup_canvas_rc" width="200" height="50"></canvas>
    </div>
    <!-- Help popups -->
    <div class="pop_content" style="width:400px" id="pop_prob_graph">
      <p>Each "match-probability curve" shows the probability of the
      <b>best</b> match to a given motif occuring at a given position in the
      input sequences.  This probability is based only on sequences that
      contain at least one match with score greater than the minimum score defined
      for this motif.</p>
      <p>Points (X,Y) on the plot are:<br>
      &nbsp;&nbsp;Y = Pr(best match occurs at position X | sequence contains a match)</p>
      <p><b>Note:</b> The plots are smoothed according to the function 
      selected from the "Smoothing" menu on the right. Setting the smoothing
      window size to 1 turns off smoothing.</p>
      <p>If a negative dataset has been supplied then two lines are drawn for
      each motif representing both datasets. The normal dataset is plotted with
      a single unbroken line whereas the negative dataset is plotted with a
      dashed line.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_plotting">
      <p>This shows a listing of all motifs currently plotted on the graph.</p>
      <p>The color used to plot a motif can be changed by clicking on the
      color swatch next to the motif you want to change, followed by clicking
      on the color swatch you wish to swap it with.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_unused_colours">
      <p>These are extra colors you may use for plotting motifs.</p>  
      <p>Click on the color swatch next to one of the above motifs, then click 
      on one of these "unused color" swatches to change the color of the 
      motif's plot.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" style="width: 500px" id="pop_graph">
      <p>These options change the display of the graph.</p>
      <dl>
        <dt>Smoothing:</dt>
        <dd><p>Allows selection of the smoothing function applied to the graph.</p>
        <p>The weighted moving average option uses weights shaped as an isosceles 
        triangle where the central point (or points in an even sized window) 
        get the maximum weight.</p>
        <p>The moving average simply weights all points in the smoothing window 
        equally.</p> 
        <p><b>Note:</b> Setting the smoothing window size to 1 turns off 
        smoothing.</dd></p>
        <dt>Window</dt>
        <dd><p>The window size used to smooth the graph. The larger the smoothing
        window size, the smoother the graph, at the cost of hiding detail.</p> 
        <p>Below a smoothing window size of 10, thinner lines are used on the 
        graph to allow more detail to be visible.</p>
        <p><b>Note:</b> Remember to press "return" or "enter" after changing 
        the number in the input box in order to see the effect of the new 
        smoothing window size.</p></dd>
        <dt>Legend</dt>
        <dd><p>Choose to display/disable the on-graph legend. The legend can be 
        moved by clicking on the graph.</p></dd>
        <dt>Download EPS</dt>
        <dd><p>Download the graph that you are currently viewing as an 
        encapsulated postscript (EPS) image. EPS images are scalable making them
        suitable for publication.</p></dd>
      </dl>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_filtering">
      <p>List only enriched motifs that meet the selected filter criteria below.</p>
      <p><b>Selected motifs are always listed</b>; deselect all motifs first by clicking on
      the "X" above the color swatches if you wish to filter all motifs.</p>
      <p>To filter on "ID" or "Name", you can enter any Javascript regular
      expression pattern.  See <a href="http://www.w3schools.com/jsref/jsref_obj_regexp.asp">here</a>
      for documentation on Javascript regular expression patterns.</p>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_db">
      <p>The name of the database (file name) that contains the motif.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_id">
      <p>A name for the motif that is unique in the motif database file.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_name">
      <p>An alternate name of the motif that may be provided in the motif database file.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_pvalue">
      <p>The probability that any tested region would be as enriched for 
      best matches to this motif as the reported region is.</p>
      <p>By default the <i>p</i>-value is calculated by using the one-tailed
      binomial test on the number of sequences with a match to the
      motif ("Total Matches") that have their best match in the reported region ("Region Matches"),
      corrected for the number of regions and score thresholds tested ("Multiple Tests"). 
      The test assumes that the probability that the best match in a sequence falls
      in the region is the region width divided by the number of
      places a motif can align in the sequence (sequence length minus motif
      width plus 1).</p>
      <p>When CentriMo is run in discriminative mode with a negative set, the
      <i>p</i>-value of a region is calculated using the Fisher exact test
      on the enrichment of best matches in the positive sequences ("Region Matches")
      relative to the negative sequences ("Negative Region Matches"), 
      corrected for the number of regions and score thresholds tested ("Multiple Tests").  
      The test assumes that the probability that the best match falls into a given region is the same
      for all positive and negative sequences.
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_evalue">
      <p>The expected number motifs that would have least one region as enriched for 
      best matches to the motif as the reported region.  
      The <i>E</i>-value is the <i>p</i>-value
      multiplied by the number of motifs in the input database(s).</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_MCC">
      <p>The Matthew's Correlation Coefficient (MCC) gives a measure of the ability
      of the motif to discriminate the positive sequences from the negative sequences:
      <dl>
        <dt> MCC = [TP*TN - FP*FN] / [(TP + FP) * (TP + FN) * (TN + FP) * (TN + FN)]</dt>
      </dl>
      where 
      <dl>
        <dd>TP is the number of positive sequences with a best match in the reported region,</dd>
        <dd>FP is the number of negative sequences with a best match in the reported region,</dd>
        <dd>TN is the number of negative sequences without a best match in the reported region, and</dd>
        <dd>FN is the number of positive sequences without a best match in the reported region.</dd>
      </dl>
      <p>MCC ranges from -1 to +1, where a +1 result indicates that the occurrence
      of a best match to the motif in the reported region perfectly discriminates positive
      sequences from negative sequences.
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_score">
      <p>This is the score threshold for determining if a sequence contains a match to this motif.</p>
      <p>When score optimization is enabled, this column lists the score
      threshold that gives the best <i>p</i>-value. Otherwise it
      shows the smallest score found that was above the minimum score threshold
      specified to CentriMo.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_binw">
      <p>The width (in sequence positions) of the most enriched region.
      A best match to the motif is counted as being in the region if
      the center of the motif falls in the region.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_bin_sites">
      <p>The number of (positive) sequences whose <b>best</b> match to the motif 
      falls in the reported region.</p>
      <p><b>Note:</b> This number may be less than the number of (positive) sequences that
      have a best match in the region. The reason for this is that a sequence may
      have many matches that score equally best. If <i>n</i> matches have the
      best score in a sequence, 1/<i>n</i> is added to the appropriate bin
      for each match.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_neg_bin_sites">
      <p>The number of <b>negative</b> sequences where the <b>best</b> match to
      the motif falls in the reported region. This value is rounded but the
      underlying value may contain fractional counts.</p>
      <p><b>Note:</b> This number may be less than the number of <b>negative</b>
      have a best match in the region. The reason for this is that a sequence may
      have many matches that score equally best. If <i>n</i> matches have the
      best score in a sequence, 1/<i>n</i> is added to the appropriate bin
      for each match.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_total_sites">
      <p>The number of sequences containing a match to the motif above the
      score threshold ("Score Threshold").</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_neg_total_sites">
      <p>The number of <b>negative</b> sequences containing a match to the motif
      above the minimum score threshold. When score optimization is enabled the
      score threshold may be raised higher than the minimum.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_negative_binomial">
      <p>The probability that any tested region in the <b>negative</b>
      sequences would be as enriched for best matches to this motif according
      to the Binomial test.</p> 
      <p>Use the filter to display only motifs differentially enriched in both
      datasets (low <i>p</i>-value and high negative <i>p</i>-value).</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_prob">
      <p>The maximum probability that the best match occurs at any single sequence position.
      If the smoothing window size ("Window:", to right of graph) is set to "1", then this is value is
      the maximum value of the match-probability curve.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_nbinstested">
      <p>This is the number of multiple tests (<i>n</i>) done for this motif.  It was
      used to correct the original <i>p</i>-value of a region for multiple tests
      using the formula </p>
      <dl>
        <dd>p' = 1 - (1-p)^n</dd>
      </dl>
      <p>where <i>p</i> is the uncorrected <i>p</i>-value.
      The number of multiple tests is the number of regions considered times the
      number of score thresholds considered.  It depends on the motif length, sequence length, 
      and the type of optimizations being done (central enrichment, local enrichemnt, score
      optimization).</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_bin_location">
      <p>Location of the center of the most enriched region.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_SMmotifs">
      <p>The text box lists the sequence identifiers for sequences which have at
      least one of their best matches in the most significant region of <b>all</b> the
      selected motifs.</p>
      <p>The "Intersection" subheading gives the number of identifiers in the
      text box and their percentage out of the total number of input sequences.</p>
      <p>The "Union" subheading lists the number and percentage of
      sequences that have at least one of their best matches in the most
      significant region of <b>any</b> of the selected motifs and their 
      percentage out of the total number of input sequences.</p>

      <p>Note that the number of sequences with a match to a given motif in
      its best region may be larger than the value of "Region Matches". This is because
      a sequence may have multiple equally best matches and in that case a
      fractional match count is assigned to each of them when "Region Matches" is computed.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_OEbins">
      <p>When more than one significant, non-overlapping region is found,
      they can be shown (and hidden again) by clicking the arrow.</p>
      <p>By default the regions are sorted by <i>E</i>-value, but this can be
      changed by the menu on the right of the page.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_problocation">
      <p>Sequence position where the (unsmoothed) match-probability curve for this motif 
      attains its maximum.  Set the smoothing window size ("Window:", to right of graph) to
      "1" to see the unsmoothed match probability curve.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <!-- Page starts here -->
    <div id="top" class="pad1">
      <h1><img id="title_img" src="" alt="CentriMo" /></h1>
      <script>$("title_img").src = site_url + "/doc/images/centrimo_logo.png"</script>
      <p>
        For further information on how to interpret these results or to get a 
        copy of the MEME software please access 
        <a href="http://meme.nbcr.net/">http://meme.nbcr.net</a>. 
      </p>
      <p>If you use CentriMo in your research, please cite the following paper:<br />
        <span class="citation">
          Timothy L. Bailey and Philip Machanick, 
          &quot;Inferring direct DNA binding from ChIP-seq&quot;, submitted.
        </span>
      </p>
    </div>
    <!-- navigation -->
    <div class="pad2">
      <a class="jump" href="#graph_sec">Motif Probability Graph</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#data_sec">Enriched Motifs</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#inputs">Input Files</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#info_sec">Program information</a>
    </div>
    <!-- alert the user when their browser is not up to the task -->
    <noscript><h1 style="color:red">Javascript is required to view these results!</h1></noscript>
    <h1 id="html5_warning" style="color:red; display:none;">Your browser does not support canvas!</h1>
    <script>
      if (!window.HTMLCanvasElement) $("html5_warning").style.display = "block";
    </script>
    <h2 class="mainh pad2">Results</h2>
    <div class="box">
      <span id="ins_desc"></span>
      <!-- write out the job description -->
      <script>
        if (data['job_description']) {
          var node = $("ins_desc");
          while (node.firstChild) node.removeChild(node.firstChild);
          var header = document.createElement("h4");
          header.id = "description";
          header.appendChild(document.createTextNode("Description"));
          node.appendChild(header);
          var paragraphs = data['job_description'].split("\n\n");
          for (var i = 0; i < paragraphs.length; i++) {
            var p = document.createElement("p");
            var lines = paragraphs[i].split("\n");
            for (var j = 0; j < lines.length; j++) {
              if (j != 0) p.appendChild(document.createElement('br'));
              p.appendChild(document.createTextNode(lines[j]));
            }
            node.appendChild(p);
          }
        }
      </script>
      <div>
        <div style="float:left; width:70%">
          <h4 id="graph_sec">Motif Probability Graph (score &ge; <span 
              id="ins_score2"></span> bits)&nbsp;<div class="help" 
              onclick="help_popup(this, 'pop_prob_graph')"></div></h4>
          <script>
            $("ins_score2").innerHTML = (data['options']['optimize_score']) ? 
            "optimal above " + data['options']['score'] : data['options']['score'];
          </script>
          <div class="graph_box">
            <div id="pop_peak" class="pop_graph_peak"></div>
            <canvas id="graph" width="700" height="400" onclick="move_legend(event)"></canvas>
          </div>
        </div>
        <div class="graph_options_section">
          <h4 id="graph_sec">Options</h4>
          <h5>Plotting&nbsp;<div class="help" onclick="help_popup(this, 'pop_plotting')"></div></h5>
          <div style="max-height:200px; min-height:100px; overflow-y: auto;">
            <table class="graph_list" id="graph_list"><tbody></tbody></table>
          </div>
          <div id="unused_colours_section">
            <h5>Unused Colours&nbsp;<div class="help" onclick="help_popup(this, 'pop_unused_colours')"></div></h5>
            <span id="unused_colours"></span>
          </div>
          <h5>Graph&nbsp;<div class="help" onclick="help_popup(this, 'pop_graph')"></div></h5>
          <div>
            <label for="plot_type">Smoothing:</label>
            <select id="plot_type" onchange="recreate_table=true; make_MP_graph(); recreate_table=false">
              <option value="0">Moving Average</option>
              <option value="1" selected>Weighted Moving Average</option>
            </select>
          </div>
          <div>
            <label for="windo">Window:</label>
            <input type="number" style="min-width:40px;" id="windo" 
            onkeypress="num_keys(event)"
            onchange="recreate_table=true; make_MP_graph(); recreate_table=false" value="20" size="2" min="1">
          </div>
          <div>
            <label for="legend">Legend:</label>
            <select id="legend" onchange="make_MP_graph()">
              <option value="0">Disabled</option>
              <option value="1" selected>Enabled (click on graph to move)</option>
            </select>
          </div>
          <div style="margin-top:10px;"> 
            <form id="eps_form" method="post" action="">
              <script>$("eps_form").action = site_url + "/cgi-bin/echo.cgi";</script>
              <input type="hidden" name="name" value="centrimo.eps">
              <input type="hidden" name="mime_type" value="application/postscript">
              <input type="hidden" id="eps_content" name="content" value="">
              <input type="submit" onclick="download_eps()" value="Download EPS (for publication)">
            </form>
          </div>
        </div>
      </div>
      <div>
        <div style="float:left; width:70%">
          <h4 id="data_sec">Enriched motifs (<i>E</i>-value &le; 
            <span id="ins_ethresh"></span> using the 
            <span id="ins_test"></span> test)
          </h4>
          <script>
            $("ins_ethresh").innerHTML = data['options']["ethresh"];
            $("ins_test").innerHTML = ((data['options']['disc']) ? "Fisher exact" : "Binomial");
          </script>
          <table class="motifs hide_db hide_maxprob hide_tsites" id="motifs">
            <thead>
            <tr align="center">
              <th class="deselect" onclick="clear_selection()" 
                title="clear selection">&#x2612;</th>
              <th class="col_db">Database&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_db')"></div></th>
              <th class='col_id'>ID&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_id')"></div></th>
              <th class="col_name">Name&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_name')"></div></th>
              <th class='col_evalue'><i>E</i>-value&nbsp;<div class="help" 
                    onclick="help_popup(this, 'pop_evalue')"></div></th>
              <th class="col_pvalue"><i>p</i>-value&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_pvalue')"></div></th>
              <th class="col_MCC">MCC&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_MCC')"></div></th>
              <th class="col_blocation">Region Center&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_bin_location')"></div></th>
              <th class='col_bwidth'>Region Width&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_binw')"></div></th>
              <th class="col_bsites">Region Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_bin_sites')"></div></th>
              <th class="col_tsites">Total Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_total_sites')"></div></th>
              <th class="col_negbsites">Negative Region Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_neg_bin_sites')"></div></th>
              <th class="col_negtsites">Negative Total Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_neg_total_sites')"></div></th>
              <th class="col_negative_binomial">Negative <i>p</i>-value&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_negative_binomial')"></div></th>
              <th class="col_maxprob">Max Probability&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_prob')"></div></th>
              <th class="col_problocation">Max Probability Location&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_problocation')"></div></th>
              <th class="col_nbinstested">Multiple Tests&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_nbinstested')"></div></th>
              <th class="col_score">Score Threshold&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_score')"></div></th>
              <th class="col_OEbins">Other Regions&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_OEbins')"></div></th>
            </tr>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div>
        <div style="float:right; width:30%">
          <div id="seq_area">
            <h4>Matching sequences (out of <span id="ins_seqN"></span>) 
              <div class="help" onclick="help_popup(this, 'pop_SMmotifs')"></div></h4>
            <script>$("ins_seqN").innerHTML = data['sequence_db']['count'];</script>
            <h5>Union: <span id="matching_union_number">0</span> sequences 
              (<span id="matching_union_percentage">0</span>%).</h5>
            <h5>Intersection: <span id="matching_intersection_number">0</span>
              sequences (<span id="matching_intersection_percentage">0</span>%).</h5>
                    <textarea id="matching_intersection_sequences" rows="10" cols="50" readonly></textarea>
                    </div>
          <h4>Sort &amp; Filter</h4>
          <div style="margin-top:10px;">
            <h5>Sort</h5>
            <div id="box_peak_sort">
              <label for="peak_sort">Peaks: </label>
              <select id="peak_sort">
                <option value="0" selected><i>E</i>-value (also <i>p</i>-value)</option>
                <option value="1">Matthew's Correlation Coefficient </option>
                <option value="2">Region Center</option>
                <option value="3">Region Width</option>
                <option value="4">Region Matches</option>
                <option value="5"><i>p</i>-value in Negative Dataset</option>
                <option value="6">Region Matches in Negative Dataset</option>
              </select>
            </div>
            <div>
              <label for="motif_sort">Motifs: </label>
              <select id="motif_sort">
                <option value="0">ID</option>
                <option value="1">Name</option>
                <option value="2" selected><i>E</i>-value (also <i>p</i>-value)</option>
                <option value="3">Matthew's Correlation Coefficient </option>
                <option value="4">Region Center</option>
                <option value="5">Region Width</option>
                <option value="6">Region Matches</option>
                <option value="7">Total Matches</option>
                <option value="8">Max Probability</option>
              </select>
            </div>
            <script>
              if (!data['options']['mcc']) {
                $('peak_sort')[1].style.display= 'none';
                $('motif_sort')[3].style.display= 'none';
              }
              if (!data['options']['disc']) {
                $('peak_sort')[5].style.display = 'none';
                $('peak_sort')[6].style.display = 'none';
              }
            </script>
          </div>
          <h5>Filters&nbsp;<div style="margin-top:5px;" class="help" 
              onclick="help_popup(this, 'pop_filtering')" ></div></h5>
          <div id="filters">
            <div >
              <input type="checkbox" id="filter_on_top" value="1" 
              onclick="toggle_filter(this, 'filter_top')">
              <label for="filter_top" 
                onclick="enable_filter('filter_on_top', 'filter_top')">Top</label>
              <input type="number" id="filter_top" value="10" size="4" min="1"
              onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_db" value="1" 
              onclick="toggle_filter(this, 'filter_db')">
              <label for="filter_db" 
                onclick="enable_filter('filter_on_db', 'filter_db')"
                >Database is</label>
              <select id="filter_db" disabled>
                <script>
                  var filter_db = $("filter_db");
                  filter_db.options.length = 0;
                  for (var i = 0; i < data['motif_dbs'].length; i++) {
                    var db = data['motif_dbs'][i];
                    filter_db.add(new Option(db['name'], i));
                  }
                </script> 
              </select>
            </div>
            <div >
              <input type="checkbox" id="filter_on_id" value="1" 
              onclick="toggle_filter(this, 'filter_id')">
              <label for="filter_id" 
                onclick="enable_filter('filter_on_id', 'filter_id')"
                >ID matches</label>
              <input type="text" id="filter_id" value=".*" size="12" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_alt" value="1" 
              onclick="toggle_filter(this, 'filter_alt')">
              <label for="filter_alt"
                onclick="enable_filter('filter_on_alt', 'filter_alt')"
                >Name matches</label>
              <input type="text" id="filter_alt" value=".*" size="12" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_evalue" value="1" 
              onclick="toggle_filter(this, 'filter_evalue')">
              <label for="filter_evalue"
                onclick="enable_filter('filter_on_evalue', 'filter_evalue')"
                ><i>E-value</i> &le;</label>
              <input type="text" id="filter_evalue" value="1" size="7" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_binwidth" value="1" 
              onclick="toggle_filter(this, 'filter_binwidth')">
              <label for="filter_binwidth"
                onclick="enable_filter('filter_on_binwidth', 'filter_binwidth')"
                >Region Width &le;</label>
              <input type="number" id="filter_binwidth" value="200" size="7" 
              min="1" onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
            <div id='CB_filter_on_negbintest'>
              <input type="checkbox" id="filter_on_negbintest" value="1" 
              onclick="toggle_filter(this, 'filter_negbintest')">
              <label for="filter_negbintest"
                onclick="enable_filter('filter_on_negbintest', 'filter_negbintest')"
                >Negative set <i>E</i>-value &ge;</label>
              <input type="text" id="filter_negbintest" value="1" size="7" 
              min="1" onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
          </div>
          <div>
            <input type="button" value="Update" onclick="make_CEM_table()">
          </div>
          <h4>Columns to display</h4>
          <div >
            <input type="checkbox" id="show_db" value="1" 
            onclick="toggle_column('hide_db')">
            <label for="show_db">Show Database</label>
          </div>
          <div >
            <input type="checkbox" id="show_id" value="1" 
            onclick="toggle_column('hide_id')" checked>
            <label for="show_id">Show ID</label>
          </div>
          <div >
            <input type="checkbox" id="show_name" value="1" 
            onclick="toggle_column('hide_name')" checked>
            <label for="show_name">Show Name</label>
          </div>
           <div >
            <input type="checkbox" id="show_evalue" value="1" 
            onclick="toggle_column('hide_evalue')" checked>
            <label for="show_evalue">Show <i>E</i>-value</label>
          </div>
          <div >
            <input type="checkbox" id="show_pvalue" value="1" 
            onclick="toggle_column('hide_pvalue')" checked>
            <label for="show_pvalue">Show <i>p</i>-value</label>
          </div>
          <div id='CB_show_MCC'>
            <input type="checkbox" id="show_MCC" value="1" 
            onclick="toggle_column('hide_MCC')">
            <label for="show_MCC">Show Matthew's Correlation Coefficient</label>
          </div>
          <div id='CB_show_blocation'>
            <input type="checkbox" id="show_blocation" value="1" 
            onclick="toggle_column('hide_blocation')" checked>
            <label for="show_blocation">Show Region Center</label>
          </div>
          <div >
            <input type="checkbox" id="show_bwidth" value="1" 
            onclick="toggle_column('hide_bwidth')" checked>
            <label for="show_bwidth">Show Region Width</label>
          </div>
          <div >
            <input type="checkbox" id="show_bsites" value="1" 
            onclick="toggle_column('hide_bsites')" checked>
            <label for="show_bsites">Show Region Matches</label>
          </div>
          <div >
            <input type="checkbox" id="show_tsites" value="1" 
            onclick="toggle_column('hide_tsites')" checked>
            <label for="show_tsites">Show Total Matches</label>
          </div>
          <div id='CB_show_negbsites'>
            <input type="checkbox" id="show_negbsites" value="1" 
            onclick="toggle_column('hide_negbsites')">
            <label for="show_negbsites">Show Negative Region Matches</label>
          </div>
          <div id='CB_show_negtsites'>
            <input type="checkbox" id="show_negtsites" value="1" 
            onclick="toggle_column('hide_negtsites')">
            <label for="show_negtsites">Show Negative Total Matches</label>
          </div>
          <div id='CB_show_negative_binomial'>
            <input type="checkbox" id="show_negative_binomial" value="1" 
            onclick="toggle_column('hide_negative_binomial')">
            <label for="show_negative_binomial">Show Negative <i>p</i>-value</label>
          </div>
          <div >
            <input type="checkbox" id="show_maxprob" value="1" 
            onclick="toggle_column('hide_maxprob')">
            <label for="show_maxprob">Show Max Probability</label>
          </div>
          <div >
            <input type="checkbox" id="show_hpeak" value="1" 
            onclick="toggle_column('hide_hpeak')">
            <label for="show_hpeak">Show Max Probability Location</label>
          </div>
          <div >
            <input type="checkbox" id="show_nbinstested" value="1" 
            onclick="toggle_column('hide_nbinstested')">
            <label for="show_nbinstested">Show Multiple Tests</label>
          </div>
          <div>
            <input type="checkbox" id="show_score" value="1" 
            onclick="toggle_column('hide_score')" checked>
            <label for="show_score">Show Score Threshold</label>
          </div>
        </div>
        <div style="clear:both"></div>
      </div>
    </div>
    <h2 id="inputs" class="mainh pad2">Input Files</h2>
    <div class="box">
      <h4>Sequences</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Sequence Count</th></tr>
        <tr>
          <td id="ins_seq_name"></td>
          <td id="ins_seq_source"></td>
          <td id="ins_seq_count"></td>
        </tr>
      </table>
      <script>
      {
        var db = data['sequence_db'];
        $("ins_seq_name").innerHTML = db['name'];
        $("ins_seq_source").innerHTML = db['source'];
        $("ins_seq_count").innerHTML = db['count'];
      }
      </script>
      <div id='neg_seq_input'>
      <h4>Negative sequences</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Sequence Count</th></tr>
        <tr>
          <td id="ins_negseq_name"></td>
          <td id="ins_negseq_source"></td>
          <td id="ins_negseq_count"></td>
        </tr>
      </table>
      </div>
      <script>
      {
        if (data['options']['neg_sequences']) {
          var db = data['negative_sequence_db'];
          if (!db['name']) db['name'] = name_from_source(db['source']);
          $("ins_negseq_name").innerHTML = db['name'];
          $("ins_negseq_source").innerHTML = db['source'];
          $("ins_negseq_count").innerHTML = db['count'];
        }
        else {
          $('neg_seq_input').style.display='none';
        }
      }
      </script>
      <h4>Motifs</h4>
      <table id="motif_dbs" class="inputs">
        <thead>
          <tr><th>Database</th><th>Source</th><th>Motif Count</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <script>
      {
        var tbl = $('motif_dbs');
        var tbody = tbl.tBodies[0];
        while (tbody.rows.length > 0) {
          tbody.deleteRow(0);
        }
        var motif_dbs = data['motif_dbs'];
        for (var i = 0; i < motif_dbs.length; i++) {
          var db = motif_dbs[i];
          var row = tbody.insertRow(tbody.rows.length);
          add_text_cell(row, db['name']);
          add_text_cell(row, db['source']);
          add_text_cell(row, db['count']);
        }
      }
      </script>
    </div>
    <div id="info_sec" class="bar">
      <div class="subsection">
        <a name="version"/>
        <h5>CentriMo version</h5>
        <span id="ins_version"></span>
        (Release date: <span id="ins_release"></span>)
        <script>
          $("ins_version").innerHTML = data["version"];
          $("ins_release").innerHTML = data["release"];
        </script> 
      </div>
      <div class="subsection">
        <a name="reference"/>
        <h5>Reference</h5>
        <span class="citation">
          Timothy L. Bailey and Philip Machanick, 
          &quot;Inferring direct DNA binding from ChIP-seq&quot;, submitted.
        </span>
        <div class="subsection">
          <a name="command" />
          <h5>Command line summary</h5>
          <textarea id="cmd" rows="1" style="width:100%;" readonly="readonly">
          </textarea>
          <script>$("cmd").value = data["cmd"].join(" ");</script>
        </div>
      </div>
    </div>
  </body>
</html>
